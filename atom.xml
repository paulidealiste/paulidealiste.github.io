<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Creative morphometrics]]></title>
  <link href="http://paulidealiste.github.io/atom.xml" rel="self"/>
  <link href="http://paulidealiste.github.io/"/>
  <updated>2014-08-05T20:13:26+02:00</updated>
  <id>http://paulidealiste.github.io/</id>
  <author>
    <name><![CDATA[Miloš Blagojević]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automated Outlines With openCV in Python]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/08/05/automated-outlines-with-opencv-in-python/"/>
    <updated>2014-08-05T20:06:18+02:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/08/05/automated-outlines-with-opencv-in-python</id>
    <content type="html"><![CDATA[<p>Quantification of biological shape often relies on manual extraction of information from a set of digital images or 3D models, like manual landmark placement or outlining the object of interest by hand. With computer vision approach and, especially, with the help of the <a href = "http://opencv.org">openCV</a> library, a set of image manipulation tecniques as well as automated feature extractions are facilitated to a large extent. Since there are excellent python bindings for this library it is easy to test ideas for image analysis and object extraction in the context of geometric morphometrics.</p>

<p>This post will serve as a general introduction to openCV in python, and will continue on the earlier posts about the outline extraction from digital photos usual in GM research. The sample image can be obtained <a href = "http://goo.gl/eDtqdn"> here</a>.</p>

<figure class='code'><figcaption><span>Library import, reading and displaying the image</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">cv2</span> <span class="c">#this is the main openCV class, the python binding file should be in /pythonXX/Lib/site-packages</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</span><span class='line'>
</span><span class='line'><span class="n">gwash</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s">&quot;~/taster1.JPG&quot;</span><span class="p">)</span> <span class="c">#import image</span>
</span><span class='line'><span class="n">gwashBW</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">gwash</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="c">#change to grayscale</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gwashBW</span><span class="p">,</span> <span class="s">&#39;gray&#39;</span><span class="p">)</span> <span class="c">#this is matplotlib solution (Figure 1)</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([]),</span> <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">&#39;gwash&#39;</span><span class="p">,</span> <span class="n">gwashBW</span><span class="p">)</span> <span class="c">#this is for native openCV display</span>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/figure_1gbw.png" width="600" height="468" title="'Original image'" ></p>

<p>This image is suitable for automated online extraction of the skull, since there is a significant ammount of contrast of the object and the background. The idea is to use thresholding and a bit of erosion around the edges to delimit the skull from the rest of the picture and then apply automated contour extractions.</p>

<figure class='code'><figcaption><span>Image threshold, erosion and contour extraction</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">ret</span><span class="p">,</span><span class="n">thresh1</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">gwashBW</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span> <span class="c">#the value of 15 is chosen by trial-and-error to produce the best outline of the skull</span>
</span><span class='line'><span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="c">#square image kernel used for erosion</span>
</span><span class='line'><span class="n">erosion</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">erode</span><span class="p">(</span><span class="n">thresh1</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="c">#refines all edges in the binary image</span>
</span><span class='line'>
</span><span class='line'><span class="n">opening</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">erosion</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">MORPH_OPEN</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
</span><span class='line'><span class="n">closing</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">opening</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">MORPH_CLOSE</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span> <span class="c">#this is for further removing small noises and holes in the image</span>
</span><span class='line'>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">closing</span><span class="p">,</span> <span class="s">&#39;gray&#39;</span><span class="p">)</span> <span class="c">#Figure 2</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([]),</span> <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">closing</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">RETR_TREE</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)</span> <span class="c">#find contours with simple approximation</span>
</span><span class='line'>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">&#39;cleaner&#39;</span><span class="p">,</span> <span class="n">closing</span><span class="p">)</span> <span class="c">#Figure 3</span>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">closing</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/figure_2teoc.png" width="600" height="470" title="'Binary image'" >
<img class="center" src="http://paulidealiste.github.io/images/figure_3econ.png" width="600" height="468" title="'Extracted contours'" ></p>

<p>Finally, since other objects of no interest are also outlined in Figure 3, the skull outline must be identified in the array list contours. This can be done by a for loop, and the openCV method for calculating outline areas, as the skull outline is the longest continual outline in the image.</p>

<figure class='code'><figcaption><span>Calculating outline areas and extracting the skull outline</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#list to hold all areas</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
</span><span class='line'>  <span class="n">ar</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
</span><span class='line'>  <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">max_area</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
</span><span class='line'><span class="n">max_area_index</span> <span class="o">=</span> <span class="n">areas</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_area</span><span class="p">)</span> <span class="c">#index of the list element with largest area</span>
</span><span class='line'>
</span><span class='line'><span class="n">cnt</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="n">max_area_index</span><span class="p">]</span> <span class="c">#largest area contour</span>
</span><span class='line'>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">closing</span><span class="p">,</span> <span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maxLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">&#39;cleaner&#39;</span><span class="p">,</span> <span class="n">closing</span><span class="p">)</span>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/figure_4fec.png" width="600" height="469" title="'One contour'" ></p>

<p>The extracted contour is a numpy array with xy coordinates of contour points in rows, so it can be directly used for sampling landmarks along the outline for fitting the normalized Fourier transform and doing shape analysis further. Of course, the procedure can be easily generalized to work over all images in a dataset, extract the contours with largest areas from each image, and generate a dataset for shape analysis.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Project and Explore]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/07/07/python-project-and-explore/"/>
    <updated>2014-07-07T17:21:08+02:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/07/07/python-project-and-explore</id>
    <content type="html"><![CDATA[<p>Since Procrustes superimposition introduces the data into a curved shape space which corresponds to a hyperhemisphere of radius 1 with numerous dimensions (as defined by Rohlf, 1999<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>), usual multivariate statistical methods are not readily applicable to such data. This data must be projected to a flat, Euclidean tangent space, that is in contact with the hyperhemisphere in one point, taken as a mean shape of the whole dataset. This projection can be applied only if the variation in shapes in not overtly large so that their &ldquo;shadows&rdquo; on a flat space are not too far apart. In this post, data will be generated as usual and Procrustes procedures will be taken from previous posts, using defined functions <em>centsiz</em>, <em>transScale</em>, <em>mshapr</em>, <em>pProc</em> and <em>pGP</em>.</p>

<figure class='code'><figcaption><span>Importing libraries, generating data and utility functions</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">Pycluster</span> <span class="kn">as</span> <span class="nn">pyc</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">brewer2mpl</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
</span><span class='line'>
</span><span class='line'><span class="n">coordstest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">175</span><span class="p">,</span> <span class="mi">210</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>    <span class="c">#slightly larger variation</span>
</span><span class='line'>                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">175</span><span class="p">,</span> <span class="mi">210</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
</span><span class='line'><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">coordstest</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">200</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
</span><span class='line'><span class="n">coordinates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="c">#coordinates column</span>
</span><span class='line'><span class="n">individuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span><span class="mi">10</span><span class="p">)</span> <span class="c">#individuals column</span>
</span><span class='line'><span class="n">allCoords</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'><span class="n">allCoords</span><span class="p">[</span><span class="s">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coordinates</span>
</span><span class='line'><span class="n">allCoords</span><span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">individuals</span>
</span><span class='line'><span class="n">allCoords</span> <span class="o">=</span> <span class="n">allCoords</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">,</span><span class="s">&#39;coordinates&#39;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>After Procrustes superimposition, data can be projected orthogonally and stereographically. More common method is the orthogonal projection which minimizes lagre shape differences between landmark configurations. The procedure is based on Rohlf, 1999, suggesting that the matrix of aligned centered preshapes should be multiplied by the mean shape of unit centroid size, subtracted from the identity matrix of comparable dimensionality (Claude, 2008).</p>

<figure class='code'><figcaption><span>Orthogonal projection of superimposed data, Procrustes superimposition and projection</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">ortproj</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">numland</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">numind</span><span class="p">):</span> <span class="c">#where A is a pandas dataframe (tempCoords), numind =  landmarks, numind =  individuals</span>
</span><span class='line'>  <span class="n">mshape</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</span><span class='line'>  <span class="n">mshStd</span> <span class="o">=</span> <span class="n">mshape</span><span class="o">/</span><span class="n">centsize</span><span class="p">(</span><span class="n">mshape</span><span class="p">)</span>
</span><span class='line'>  <span class="n">mshMel</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">mshStd</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s">&#39;variable&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</span><span class='line'>  <span class="c">#mshRep = pd.concat([mshMel]*numind, ignore_index = True) #calculate repeating size standardized meanShape</span>
</span><span class='line'>  <span class="n">mshRep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">numind</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">mshMel</span><span class="p">)</span>
</span><span class='line'>  <span class="n">simDia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">numland</span> <span class="o">*</span> <span class="n">dim</span><span class="p">)</span> <span class="c">#identity matrix</span>
</span><span class='line'>  <span class="c">#lonWid = A[[&quot;x&quot;,&quot;y&quot;]].values.reshape(numind,numland*dim) #must have column names &quot;x&quot; and &quot;y&quot; for coordinates</span>
</span><span class='line'>  <span class="n">lonWidX</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">numind</span><span class="p">,</span><span class="n">numland</span><span class="p">)</span>
</span><span class='line'>  <span class="n">lonWidY</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="s">&quot;y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">numind</span><span class="p">,</span><span class="n">numland</span><span class="p">)</span>
</span><span class='line'>  <span class="n">lonWid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">lonWidX</span><span class="p">,</span> <span class="n">lonWidY</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="n">temp1</span> <span class="o">=</span> <span class="n">simDia</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mshMel</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">mshMel</span><span class="p">)</span>
</span><span class='line'>  <span class="n">Xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lonWid</span><span class="p">,</span> <span class="n">temp1</span><span class="p">)</span> <span class="c">#orthogonal according to Rholf</span>
</span><span class='line'>  <span class="n">Xproj</span> <span class="o">=</span> <span class="n">Xi</span> <span class="o">+</span> <span class="n">mshRep</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">Xproj</span>
</span><span class='line'>
</span><span class='line'><span class="n">procCoords</span> <span class="o">=</span> <span class="n">pGP</span><span class="p">(</span><span class="n">allCoords</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c">#perform Procrustes superimposition</span>
</span><span class='line'><span class="n">procoordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="mi">200</span><span class="p">)</span>
</span><span class='line'><span class="n">procindividuals</span> <span class="o">=</span> <span class="n">allCoords</span><span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">]</span>
</span><span class='line'><span class="n">procCoords</span><span class="p">[</span><span class="s">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">procoordinates</span>
</span><span class='line'><span class="n">procCoords</span><span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">procindividuals</span><span class="p">)</span>
</span><span class='line'><span class="n">projCoords</span> <span class="o">=</span> <span class="n">ortproj</span><span class="p">(</span><span class="n">procCoords</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="c">#perform orthogonal projection</span>
</span></code></pre></td></tr></table></div></figure>


<p>Numpy array projCoords holds wide representation of projected data (rows are individuals, while columns are all landmarks, first all x and then y coordinates), ready to be used in PCA or any other multivariate method. In order to illustrate potential grouping in PCA morphospace, since the data is randomly generated, a kmeans clustering will be performed with 3 groups, just to effectively split the data. PCA can be done in python in numerous ways, but in this post a PCA decomposition from <em>scikit-learn</em> package is used.</p>

<figure class='code'><figcaption><span>PCA, cluster analysis and plots</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">projCoords</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">projCoordsP</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">projCoords</span><span class="p">)</span> <span class="c">#get the individual scores on PC axes</span>
</span><span class='line'>
</span><span class='line'><span class="n">clusters</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pyc</span><span class="o">.</span><span class="n">kcluster</span><span class="p">(</span><span class="n">projCoordsP</span><span class="p">,</span> <span class="n">nclusters</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="s">&#39;e&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'><span class="n">set2</span> <span class="o">=</span> <span class="n">brewer2mpl</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="s">&#39;RdYlBu&#39;</span><span class="p">,</span> <span class="s">&#39;diverging&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">mpl_colors</span> <span class="c">#generate nice colors</span>
</span><span class='line'><span class="n">projCoordsPa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">projCoordsP</span><span class="p">,</span> <span class="n">clusters</span><span class="p">))</span> <span class="c">#concatenate all for sequential plot-building</span>
</span><span class='line'>
</span><span class='line'><span class="n">group1PCA</span> <span class="o">=</span> <span class="n">projCoordsPa</span><span class="p">[</span><span class="n">projCoordsPa</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="c">#split by group for sequential plot-building</span>
</span><span class='line'><span class="n">group2PCA</span> <span class="o">=</span> <span class="n">projCoordsPa</span><span class="p">[</span><span class="n">projCoordsPa</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
</span><span class='line'><span class="n">group3PCA</span> <span class="o">=</span> <span class="n">projCoordsPa</span><span class="p">[</span><span class="n">projCoordsPa</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>
</span><span class='line'><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
</span><span class='line'><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">group1PCA</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">group1PCA</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">group1PCA</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="s">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">set2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;Group1&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">group2PCA</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">group2PCA</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">group2PCA</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="s">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">set2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;Group2&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">group3PCA</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">group3PCA</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">group3PCA</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="s">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">set2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;Group3&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&quot;PCA with grouping according to kmeans 3 group solution&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;PC1 (14.45%)&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;PC2 (13.29%)&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s">&#39;PC3 (12.46%)&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since the data is randomly generated, there is not much structured variation in it, as three of the first PC axes describe 14.45%, 13.29% and 12.46% of total sample variability, respectively. On the other hand, kmeans forces the data into three groups, which is useful for demonstration of plotting in matplotlib with 3D axes, and a groupping structure in PCA scatterplots (Figure 1), similar to real-world data.</p>

<p><img class="center" src="http://paulidealiste.github.io/images/TDPCAscatter.png" width="650" height="484" title="'PCA of projected and superimposed data'" ></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Rohlf, J.F. 1999. Shape statistics: Procrustes superimpositions and tangent spaces. <em>Journal of Classification</em> <strong>16</strong>: 197-223.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Angles and Nice Plots]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/06/09/simple-angles-and-nice-plots/"/>
    <updated>2014-06-09T17:28:06+02:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/06/09/simple-angles-and-nice-plots</id>
    <content type="html"><![CDATA[<p>Angles were important for some of the most interesting research in morphometrics. The approach of Rao and Suryawanshi, 1998<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. introduced the angles within the landmark triangulation grids as an alternative to Procrustes superimposition for extracting shape data. This post does not perform the procedures described by Rao (which are ported to R in &ldquo;Geometric morphometrics in R&rdquo; by J.Claude, 2008), but instead aims at extracting angle data, from configurations of landmarks, after Procrustes superimposition. The code presented here is motivated by the <em>polarRotator</em> function from some of the previous pyhton-related posts, and it presents landmark data as polar angles. These angles represent the angular deviation of each landmark from the centroid of the respective configuration (Figure 1), so that the variability in their position with respect to xy centroid coordinates, may represent their shape differences. Since superimposition procedure sets all configurations centroids to the origin, they are all 0,0. Dataset used is the same as for the triangulation post.</p>

<figure class='code'><figcaption><span>Plotting the circle, centroid axes and mean configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>library<span class="p">(</span>geomorph<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>ggplot2<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>reshape2<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>plyr<span class="p">)</span>
</span><span class='line'>theme_set<span class="p">(</span>theme_bw<span class="p">())</span>
</span><span class='line'>
</span><span class='line'>load<span class="p">(</span><span class="s">&quot;capSample.RData&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>capGPA <span class="o">&lt;-</span> gpagen<span class="p">(</span>capSample<span class="p">)</span>
</span><span class='line'>capCoords <span class="o">&lt;-</span> capGPA<span class="o">$</span>coords
</span><span class='line'>mshapeCap <span class="o">&lt;-</span> mshape<span class="p">(</span>capCoords<span class="p">)</span> <span class="c1">#mean configuration is great for illustrations</span>
</span><span class='line'>capCentro <span class="o">&lt;-</span> capGPA<span class="o">$</span>Csize
</span><span class='line'>
</span><span class='line'>circleFun <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>center <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">),</span> npoints <span class="o">=</span> <span class="m">100</span><span class="p">)</span> <span class="c1">#drawing an enlosing circle set at the origin (0,0)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  r <span class="o">=</span> <span class="m">0.5</span>
</span><span class='line'>  tt <span class="o">&lt;-</span> seq<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="o">*</span>pi<span class="p">,</span>length.out <span class="o">=</span> npoints<span class="p">)</span>
</span><span class='line'>  xx <span class="o">&lt;-</span> center<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">+</span> r <span class="o">*</span> cos<span class="p">(</span>tt<span class="p">)</span>
</span><span class='line'>  yy <span class="o">&lt;-</span> center<span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">+</span> r <span class="o">*</span> sin<span class="p">(</span>tt<span class="p">)</span>
</span><span class='line'>  <span class="kr">return</span><span class="p">(</span>data.frame<span class="p">(</span>x <span class="o">=</span> xx<span class="p">,</span> y <span class="o">=</span> yy<span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>enclosing <span class="o">&lt;-</span> circleFun<span class="p">(</span>npoints <span class="o">=</span> <span class="m">100</span><span class="p">)</span> <span class="c1">#it should be centered at zero and have diameter 0.5</span>
</span><span class='line'>ggCirc <span class="o">&lt;-</span> ggplot<span class="p">(</span>enclosing<span class="p">,</span> aes<span class="p">(</span>x<span class="o">=</span>x<span class="p">,</span>y<span class="o">=</span>y<span class="p">))</span> <span class="o">+</span> geom_path<span class="p">(</span>size <span class="o">=</span> <span class="m">1</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;darkgrey&quot;</span><span class="p">,</span> linetype <span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>ggCirc <span class="o">&lt;-</span> ggCirc <span class="o">+</span> geom_hline<span class="p">(</span>size <span class="o">=</span> <span class="m">1</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;darkgrey&quot;</span><span class="p">,</span> linetype <span class="o">=</span> <span class="m">1</span><span class="p">)</span> <span class="o">+</span> geom_vline<span class="p">(</span>size <span class="o">=</span> <span class="m">1</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;darkgrey&quot;</span><span class="p">,</span> linetype <span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>linesAng <span class="o">&lt;-</span> data.frame<span class="p">(</span>x1 <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> y1 <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> x2 <span class="o">=</span> mshapeCap<span class="p">[,</span><span class="m">1</span><span class="p">],</span> y2 <span class="o">=</span> mshapeCap<span class="p">[,</span><span class="m">2</span><span class="p">])</span> <span class="c1">#point coordinates</span>
</span><span class='line'>linesAng <span class="o">&lt;-</span> data.frame<span class="p">(</span>linesAng<span class="p">,</span> x3 <span class="o">=</span> linesAng<span class="o">$</span>x2 <span class="o">*</span> <span class="m">20</span><span class="p">,</span> y3 <span class="o">=</span> linesAng<span class="o">$</span>y2 <span class="o">*</span><span class="m">20</span><span class="p">)</span> <span class="c1">#so that the lines would extend through landmarks</span>
</span><span class='line'>
</span><span class='line'>ggCirc <span class="o">&lt;-</span> ggCirc <span class="o">+</span> geom_segment<span class="p">(</span>data <span class="o">=</span> linesAng<span class="p">,</span> aes<span class="p">(</span>x <span class="o">=</span> x1<span class="p">,</span> y <span class="o">=</span> y1<span class="p">,</span> xend <span class="o">=</span> x3<span class="p">,</span> yend <span class="o">=</span> y3<span class="p">),</span> colour <span class="o">=</span> <span class="s">&quot;lightblue&quot;</span><span class="p">,</span> size <span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>ggCirc <span class="o">&lt;-</span> ggCirc <span class="o">+</span> geom_point<span class="p">(</span>size <span class="o">=</span> <span class="m">4.2</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;orange&quot;</span><span class="p">,</span> data <span class="o">=</span> data.frame<span class="p">(</span>mshapeCap<span class="p">),</span> aes<span class="p">(</span>x<span class="o">=</span>X1<span class="p">,</span> y <span class="o">=</span> X2<span class="p">))</span>
</span><span class='line'>ggCirc <span class="o">&lt;-</span> ggCirc <span class="o">+</span> geom_text<span class="p">(</span>data <span class="o">=</span> data.frame<span class="p">(</span>mshapeCap<span class="p">),</span> aes<span class="p">(</span>x<span class="o">=</span>X1<span class="p">,</span> y <span class="o">=</span> X2<span class="p">,</span> label <span class="o">=</span> c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">16</span><span class="p">)),</span> vjust <span class="o">=</span> <span class="m">-1.2</span><span class="p">)</span>
</span><span class='line'>ggCirc <span class="o">&lt;-</span> ggCirc <span class="o">+</span> coord_cartesian<span class="p">(</span>xlim<span class="o">=</span> c<span class="p">(</span><span class="m">-0.55</span><span class="p">,</span> <span class="m">0.55</span><span class="p">),</span> ylim<span class="o">=</span> c<span class="p">(</span><span class="m">-0.55</span><span class="p">,</span> <span class="m">0.55</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p> <br/>
<img class="center" src="http://paulidealiste.github.io/images/AnglesLandmarks.png" width="500" height="478" title="'Landmarks polar angles'" ></p>

<p><em>ggplot2</em> has one great geom, polar_angle() that will transform any shape, from Cartesian to polar coordinates. Unfortunately it does not give polar angles as well, but the plot is informative (Figure 2), since landmarks are ordered according to their angular deviation from 0, i.e. the X and Y axes defining the 0.5 centroid-centered ellipse.</p>

<figure class='code'><figcaption><span>Polar coordinate system in ggplot2</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>ggPolar <span class="o">&lt;-</span> ggplot<span class="p">(</span>data.frame<span class="p">(</span>mshapeCap<span class="p">),</span> aes<span class="p">(</span>x<span class="o">=</span>X1<span class="p">,</span> y<span class="o">=</span>X2<span class="p">))</span> <span class="o">+</span> geom_point<span class="p">(</span>size <span class="o">=</span> <span class="m">4.2</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;orange&quot;</span><span class="p">)</span>
</span><span class='line'>ggPolar <span class="o">&lt;-</span> ggPolar <span class="o">+</span> geom_text<span class="p">(</span>aes<span class="p">(</span>label <span class="o">=</span> c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">16</span><span class="p">)),</span> vjust <span class="o">=</span> <span class="m">1.5</span><span class="p">)</span>
</span><span class='line'>ggPolar <span class="o">&lt;-</span> ggPolar <span class="o">+</span> coord_polar<span class="p">(</span>start <span class="o">=</span> <span class="m">0</span><span class="p">)</span> <span class="o">+</span> xlab<span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="o">+</span> ylab<span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/AnglesPolar.png" width="500" height="436" title="'Landmarks polar coordinate system'" ></p>

<p>Polar angles can be calculated by using the atan2 (arctangent) function, which takes two parameters, x and y and gives one point estimate of the polar angle in radians. This number is really the angle between the positive x-axis of a plane (X from Figure 1) and the point given by its xy coordinates. Since after superimposition the x-axis lies at zero for all landmark configurations, it would be sufficent to use only xy coodinates of landmarks, since centroids are also at 0.</p>

<figure class='code'><figcaption><span>Polar angles with atan2 function</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>polarAngler <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>A<span class="p">)</span> <span class="c1">#function to calculate polar angles from the array</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  siz <span class="o">&lt;-</span> dim<span class="p">(</span>A<span class="p">)[</span><span class="m">3</span><span class="p">]</span>
</span><span class='line'>  len <span class="o">&lt;-</span> dim<span class="p">(</span>A<span class="p">)[</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>  polarAngles <span class="o">&lt;-</span> vector<span class="p">(</span><span class="s">&quot;list&quot;</span><span class="p">,</span> siz<span class="p">)</span>
</span><span class='line'>  <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>siz<span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    temp <span class="o">&lt;-</span> atan2<span class="p">(</span>A<span class="p">[,</span><span class="m">2</span><span class="p">,</span>i<span class="p">],</span> A<span class="p">[,</span><span class="m">1</span><span class="p">,</span>i<span class="p">])</span>
</span><span class='line'>    polarAngles<span class="p">[[</span>i<span class="p">]]</span> <span class="o">&lt;-</span> temp
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  polarAngles <span class="o">&lt;-</span> array<span class="p">(</span>unlist<span class="p">(</span>polarAngles<span class="p">),</span> dim <span class="o">=</span> c<span class="p">(</span>len<span class="p">,</span><span class="m">1</span><span class="p">,</span>siz<span class="p">))</span>
</span><span class='line'>  <span class="kr">return</span><span class="p">(</span>polarAngles<span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>library<span class="p">(</span>circular<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>colortools<span class="p">)</span>
</span><span class='line'>
</span><span class='line'>pAngles <span class="o">&lt;-</span> polarAngler<span class="p">(</span>capCoords<span class="p">)</span> <span class="c1">#angles for all configurations</span>
</span><span class='line'>mAngles <span class="o">&lt;-</span> apply<span class="p">(</span>pAngles<span class="p">,</span> <span class="m">1</span><span class="p">,</span> mean<span class="p">)</span> <span class="c1">#mean angles for each landmark</span>
</span><span class='line'>col1 <span class="o">&lt;-</span> pals<span class="p">(</span><span class="s">&quot;fish&quot;</span><span class="p">)</span> <span class="c1">#paletes from colortools</span>
</span><span class='line'>col2 <span class="o">&lt;-</span> pals<span class="p">(</span><span class="s">&quot;ocean&quot;</span><span class="p">)</span>
</span><span class='line'>col3 <span class="o">&lt;-</span> pals<span class="p">(</span><span class="s">&quot;mystery&quot;</span><span class="p">)</span>
</span><span class='line'>colorPoint <span class="o">&lt;-</span> c<span class="p">(</span>col1<span class="p">,</span> col2<span class="p">,</span> col3<span class="p">,</span> <span class="s">&quot;#9A76F5&quot;</span><span class="p">)</span> <span class="c1">#16 colors for landmarks in whell</span>
</span><span class='line'>
</span><span class='line'>plot.circular<span class="p">(</span>circular<span class="p">(</span>t<span class="p">(</span>mAngles<span class="p">),</span> type <span class="o">=</span> <span class="s">&quot;angles&quot;</span><span class="p">),</span> sep <span class="o">=</span> <span class="m">0.0003</span><span class="p">,</span> col <span class="o">=</span> colorPoint<span class="p">,</span> cex <span class="o">=</span> <span class="m">1.5</span><span class="p">)</span>
</span><span class='line'>legend<span class="p">(</span><span class="m">0.3</span><span class="p">,</span><span class="m">0.6</span><span class="p">,</span> legend <span class="o">=</span> <span class="m">1</span><span class="o">:</span><span class="m">16</span><span class="p">,</span> fill <span class="o">=</span> colorPoint<span class="p">,</span> cex <span class="o">=</span> <span class="m">0.7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><img class="center" src="http://paulidealiste.github.io/images/AnglesMean.png" width="500" height="436" title="'Landmarks ordered by angles'" ></p>

<p>Figure 3 shows the distribution of landmarks from along a circular path (0,     π). It is obvious that landmarks form two distinct groups, one above, and one below the x-axis, with the exception of landmarks 7, 8 and 10 which are the most parallel to the x-axis. The proportion of the overall shape variability left in these angles must be thouroghly checked, but it is not easy, since angle-data can not be analysed by conventional statistics, but by circular or compositional methods. R provides some libraries for this, <em>circular</em> and <em>CircStats</em> which are both derived from the book of Jammalamadaka and Sengupta, &ldquo;Topics in circular Statistics&rdquo; from 2001. If one more individual is added to the circle-plot (Figure 3) it can be can visually inspected how much its coordinates (landmark polar angles) deviate from the sample mean (Figure 4).</p>

<figure class='code'><figcaption><span>Adding individual 10 to circular plot</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>ce <span class="o">&lt;-</span> circular<span class="p">(</span>rbind<span class="p">(</span>t<span class="p">(</span>mAngles<span class="p">),</span> pAngles<span class="p">[,,</span><span class="m">10</span><span class="p">]))</span> <span class="c1">#deviation of individual 10 from the mean</span>
</span><span class='line'>plot.circular<span class="p">(</span>ce<span class="p">,</span> sep <span class="o">=</span> <span class="m">0.0003</span><span class="p">,</span> col <span class="o">=</span> colorPoint<span class="p">,</span> cex <span class="o">=</span> <span class="m">1.5</span><span class="p">)</span>
</span><span class='line'>legend<span class="p">(</span><span class="m">0.3</span><span class="p">,</span><span class="m">0.6</span><span class="p">,</span> legend <span class="o">=</span> <span class="m">1</span><span class="o">:</span><span class="m">16</span><span class="p">,</span> fill <span class="o">=</span> colorPoint<span class="p">,</span> cex <span class="o">=</span> <span class="m">0.7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/AnglesMean2.png" width="500" height="436" title="'Landmarks ordered by angles + 10'" ></p>

<p> Some variablity is present around landmarks 10, 6 and 5, while others are nearly or completely overlapping. The variability may not be large, but it will be checked in future posts, as well as possible PCA with the angular data.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Rao C.R. and S. Suryawanshi. 1998. Statistical analysis of shape of objects based on landmark data. <em>PNAS</em> <strong>93</strong>: 12132-12136.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Complete Procrustes in Python]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/05/17/complete-procrustes-in-python/"/>
    <updated>2014-05-17T20:38:16+02:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/05/17/complete-procrustes-in-python</id>
    <content type="html"><![CDATA[<p>Procrustes superimposition is the first analytic step in geometric morphometrics and this post shows one possible solution to performing it in Python<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, using several functions defined in previous posts. First steps include data generation and definition of functions important for extracting shape variables from randomly generated landmark data. These functions are <em>centsize</em> which calculates centroid size from a numpy array (xy data) and <em>transScale</em> which translates landmark coordinates to the origin of the coordinate system and scales them to unit centroid size. The <em>mshapr</em> function is needed in the main superimposition function since it calculates succesive mean shapes (all configurations), excluding the configuration that is currently being rotated.</p>

<figure class='code'><figcaption><span>Import libraries, function definition and data generation</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>import numpy as np
</span><span class='line'>import pandas as pd
</span><span class='line'>import matplotlib.pyplot as plt
</span><span class='line'>import scipy.spatial.distance as sd
</span><span class='line'>
</span><span class='line'>def centsize<span class="p">(</span>M<span class="p">)</span><span class="o">:</span> <span class="c1">#centroid size</span>
</span><span class='line'>  p <span class="o">=</span> M.shape<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>  csize <span class="o">=</span> np.sqrt<span class="p">(</span>np.sum<span class="p">(</span>M.var<span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="o">*</span><span class="p">(</span>p<span class="m">-1</span><span class="p">))</span>
</span><span class='line'>  <span class="kr">return</span> csize
</span><span class='line'>
</span><span class='line'>def transScale<span class="p">(</span>M<span class="p">)</span><span class="o">:</span>  <span class="c1">#translation and scale</span>
</span><span class='line'>  tM <span class="o">=</span> M <span class="o">-</span> M.mean<span class="p">()</span>
</span><span class='line'>  centSize <span class="o">=</span> centsize<span class="p">(</span>M<span class="p">)</span>
</span><span class='line'>  tM <span class="o">=</span> tM <span class="o">/</span> centSize
</span><span class='line'>  <span class="kr">return</span> tM
</span><span class='line'>
</span><span class='line'>def mshapr <span class="p">(</span>pdf<span class="p">)</span><span class="o">:</span>  <span class="c1">#which is a pandas DataFrame, coordinates and individuals columns</span>
</span><span class='line'>  meanShapes <span class="o">=</span> pd.DataFrame<span class="p">()</span>
</span><span class='line'>  dimen <span class="o">=</span> len<span class="p">(</span>allCoords.individuals.unique<span class="p">())</span>
</span><span class='line'>  <span class="kr">for</span> ind <span class="kr">in</span> range<span class="p">(</span><span class="m">0</span><span class="p">,</span> dimen<span class="p">)</span><span class="o">:</span>
</span><span class='line'>    temp <span class="o">=</span> pdf<span class="p">[</span>pdf.individuals <span class="o">!=</span> ind<span class="p">]</span>
</span><span class='line'>    meanShape <span class="o">=</span> temp.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="p">]</span>.groupby<span class="p">(</span>temp.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">2</span><span class="p">])</span>.mean<span class="p">()</span>
</span><span class='line'>    meanShapes <span class="o">=</span> meanShapes.append<span class="p">(</span>meanShape<span class="p">)</span>
</span><span class='line'>  <span class="kr">return</span> meanShapes
</span><span class='line'>
</span><span class='line'>coordstest <span class="o">=</span> np.vstack<span class="p">([</span>np.random.uniform<span class="p">(</span><span class="m">175</span><span class="p">,</span> <span class="m">220</span><span class="p">,</span> <span class="m">10</span><span class="p">),</span>   <span class="c1">#usual data generation</span>
</span><span class='line'>                        np.random.uniform<span class="p">(</span><span class="m">175</span><span class="p">,</span> <span class="m">220</span><span class="p">,</span> <span class="m">10</span><span class="p">)])</span>.T
</span><span class='line'>coords <span class="o">=</span> np.vstack<span class="p">([</span>np.random.multivariate_normal<span class="p">(</span>coordstest<span class="p">[</span>i<span class="p">,</span><span class="o">:</span><span class="p">],</span> <span class="p">[[</span><span class="m">3</span><span class="p">,</span><span class="m">0</span><span class="p">],[</span><span class="m">0</span><span class="p">,</span><span class="m">3</span><span class="p">]],</span> <span class="m">200</span><span class="p">)</span> <span class="kr">for</span> i <span class="kr">in</span> range<span class="p">(</span><span class="m">10</span><span class="p">)])</span>
</span><span class='line'>coordinates <span class="o">=</span> pd.Series<span class="p">((</span>np.arange<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">10</span><span class="p">)</span>.reshape<span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="o">*</span>np.ones<span class="p">(</span><span class="m">200</span><span class="p">)</span>.reshape<span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">-1</span><span class="p">))</span>.flatten<span class="p">())</span> <span class="c1">#coordinates column</span>
</span><span class='line'>individuals <span class="o">=</span> np.tile<span class="p">(</span>np.arange<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">200</span><span class="p">),</span><span class="m">10</span><span class="p">)</span> <span class="c1">#individuals column</span>
</span><span class='line'>allCoords <span class="o">=</span> pd.DataFrame<span class="p">(</span>coords<span class="p">,</span> columns <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'>allCoords<span class="p">[</span><span class="s">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> coordinates
</span><span class='line'>allCoords<span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">]</span> <span class="o">=</span> individuals
</span><span class='line'>allCoords <span class="o">=</span> allCoords.sort_index<span class="p">(</span>by <span class="o">=</span> <span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">,</span><span class="s">&#39;coordinates&#39;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Definition of the <em>pProc</em> function follows the same rules as in the previous post, with the robust (and ugly for now) if clause that is only included to allow either pandas DataFrame or a numpy array as the input data (both for configurations and mean shape objects). It also returns only the rotated matrix, landmark configuration (<em>pmat1</em>) and not the mean shape.</p>

<figure class='code'><figcaption><span>pProc function for two configuration matrices</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>def pProc<span class="p">(</span>mat1<span class="p">,</span> mat2<span class="p">)</span><span class="o">:</span> <span class="c1">#returning only centred preshape of mat1 on mat2</span>
</span><span class='line'>  <span class="kr">if</span> type<span class="p">(</span>mat1<span class="p">)</span> is np.ndarray and type<span class="p">(</span>mat2<span class="p">)</span> is np.ndarray<span class="o">:</span>
</span><span class='line'>    k <span class="o">=</span> mat1.shape<span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="m">-1</span>
</span><span class='line'>    m <span class="o">=</span> mat1.shape<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>    sscaledMat1 <span class="o">=</span> mat1 <span class="o">/</span> centsize<span class="p">(</span>mat1<span class="p">)</span>
</span><span class='line'>    sscaledMat2 <span class="o">=</span> mat2 <span class="o">/</span> centsize<span class="p">(</span>mat2<span class="p">)</span>
</span><span class='line'>    z1 <span class="o">=</span> sscaledMat1 <span class="o">-</span> <span class="p">[</span>sscaledMat1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>.mean<span class="p">(),</span> sscaledMat1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>.mean<span class="p">()]</span>
</span><span class='line'>    z2 <span class="o">=</span> sscaledMat2 <span class="o">-</span> <span class="p">[</span>sscaledMat2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>.mean<span class="p">(),</span> sscaledMat2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>.mean<span class="p">()]</span>
</span><span class='line'>    tempSv <span class="o">=</span> np.dot<span class="p">(</span>np.transpose<span class="p">(</span>z2<span class="p">),</span> z1<span class="p">)</span>
</span><span class='line'>    svdMat <span class="o">=</span> np.linalg.svd<span class="p">(</span>tempSv<span class="p">)</span>
</span><span class='line'>    U <span class="o">=</span> svdMat<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>    V <span class="o">=</span> svdMat<span class="p">[</span><span class="m">2</span><span class="p">]</span>
</span><span class='line'>    Ds <span class="o">=</span> svdMat<span class="p">[</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>    tempSig <span class="o">=</span> np.linalg.det<span class="p">(</span>np.dot<span class="p">(</span>np.transpose<span class="p">(</span>z1<span class="p">),</span> z2<span class="p">))</span>
</span><span class='line'>    sig <span class="o">=</span> np.sign<span class="p">(</span>tempSig<span class="p">)</span>
</span><span class='line'>    Ds<span class="p">[</span>k<span class="p">]</span> <span class="o">=</span> sig <span class="o">*</span> np.absolute<span class="p">(</span>Ds<span class="p">[</span>k<span class="p">])</span>
</span><span class='line'>    U<span class="p">[</span><span class="o">:</span><span class="p">,</span>k<span class="p">]</span> <span class="o">=</span> sig <span class="o">*</span> U<span class="p">[</span><span class="o">:</span><span class="p">,</span>k<span class="p">]</span>
</span><span class='line'>    Gam <span class="o">=</span> np.dot<span class="p">(</span>V<span class="p">,</span> np.transpose<span class="p">(</span>U<span class="p">))</span>
</span><span class='line'>    beta <span class="o">=</span> np.sum<span class="p">(</span>Ds<span class="p">)</span>
</span><span class='line'>    pmat1 <span class="o">=</span> np.dot<span class="p">(</span>z1<span class="p">,</span> Gam<span class="p">)</span>
</span><span class='line'>    pmat1 <span class="o">=</span> pd.DataFrame<span class="p">(</span>pmat1<span class="p">,</span> columns <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'>    <span class="kr">return</span> pmat1
</span><span class='line'>  <span class="kr">else</span><span class="o">:</span>
</span><span class='line'>    mat1x <span class="o">=</span> mat1.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>    mat1y <span class="o">=</span> mat1.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>    mat1 <span class="o">=</span> np.concatenate<span class="p">([</span>mat1x<span class="p">,</span> mat1y<span class="p">],</span> axis <span class="o">=</span> <span class="m">1</span><span class="p">)</span>.reshape<span class="p">(</span>mat1.shape<span class="p">[</span><span class="m">1</span><span class="p">],</span>mat1.shape<span class="p">[</span><span class="m">0</span><span class="p">])</span>.T
</span><span class='line'>    mat2x <span class="o">=</span> mat2.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>    mat2y <span class="o">=</span> mat2.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>    mat2 <span class="o">=</span> np.concatenate<span class="p">([</span>mat2x<span class="p">,</span> mat2y<span class="p">],</span> axis <span class="o">=</span> <span class="m">1</span><span class="p">)</span>.reshape<span class="p">(</span>mat2.shape<span class="p">[</span><span class="m">1</span><span class="p">],</span>mat2.shape<span class="p">[</span><span class="m">0</span><span class="p">])</span>.T
</span><span class='line'>    k <span class="o">=</span> mat1.shape<span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="m">-1</span>
</span><span class='line'>    m <span class="o">=</span> mat1.shape<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>    sscaledMat1 <span class="o">=</span> mat1 <span class="o">/</span> centsize<span class="p">(</span>mat1<span class="p">)</span>
</span><span class='line'>    sscaledMat2 <span class="o">=</span> mat2 <span class="o">/</span> centsize<span class="p">(</span>mat2<span class="p">)</span>
</span><span class='line'>    z1 <span class="o">=</span> sscaledMat1 <span class="o">-</span> <span class="p">[</span>sscaledMat1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>.mean<span class="p">(),</span> sscaledMat1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>.mean<span class="p">()]</span>
</span><span class='line'>    z2 <span class="o">=</span> sscaledMat2 <span class="o">-</span> <span class="p">[</span>sscaledMat2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>.mean<span class="p">(),</span> sscaledMat2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>.mean<span class="p">()]</span>
</span><span class='line'>    tempSv <span class="o">=</span> np.dot<span class="p">(</span>np.transpose<span class="p">(</span>z2<span class="p">),</span> z1<span class="p">)</span>
</span><span class='line'>    svdMat <span class="o">=</span> np.linalg.svd<span class="p">(</span>tempSv<span class="p">)</span>
</span><span class='line'>    U <span class="o">=</span> svdMat<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>    V <span class="o">=</span> svdMat<span class="p">[</span><span class="m">2</span><span class="p">]</span>
</span><span class='line'>    Ds <span class="o">=</span> svdMat<span class="p">[</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>    tempSig <span class="o">=</span> np.linalg.det<span class="p">(</span>np.dot<span class="p">(</span>np.transpose<span class="p">(</span>z1<span class="p">),</span> z2<span class="p">))</span>
</span><span class='line'>    sig <span class="o">=</span> np.sign<span class="p">(</span>tempSig<span class="p">)</span>
</span><span class='line'>    Ds<span class="p">[</span>k<span class="p">]</span> <span class="o">=</span> sig <span class="o">*</span> np.absolute<span class="p">(</span>Ds<span class="p">[</span>k<span class="p">])</span>
</span><span class='line'>    U<span class="p">[</span><span class="o">:</span><span class="p">,</span>k<span class="p">]</span> <span class="o">=</span> sig <span class="o">*</span> U<span class="p">[</span><span class="o">:</span><span class="p">,</span>k<span class="p">]</span>
</span><span class='line'>    Gam <span class="o">=</span> np.dot<span class="p">(</span>V<span class="p">,</span> np.transpose<span class="p">(</span>U<span class="p">))</span>
</span><span class='line'>    beta <span class="o">=</span> np.sum<span class="p">(</span>Ds<span class="p">)</span>
</span><span class='line'>    pmat1 <span class="o">=</span> np.dot<span class="p">(</span>z1<span class="p">,</span> Gam<span class="p">)</span>
</span><span class='line'>    pmat1 <span class="o">=</span> pd.DataFrame<span class="p">(</span>pmat1<span class="p">,</span> columns <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'>    <span class="kr">return</span> pmat1
</span></code></pre></td></tr></table></div></figure>


<p>Finally, the <em>pGP</em> function, that can perform partial Procrustes superimposition for any number of individuals (landmark configurations) and landmarks. Generated data has 200 individuals and 10 2D landmarks. For now this function will ask such information in the function call, so that mmat1 is pandas DataFrame with x, y, coordinates and individuals columns (generated above), numind is the number of individuals, dim is 2D (3D not yet supported), and numland is the number of landmarks. For clearer understanding of the following code, comments are included where appropriate.</p>

<figure class='code'><figcaption><span>Partial Procrustes Superimposition</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>def pGP <span class="p">(</span>mmat1<span class="p">,</span> numind<span class="p">,</span> dim<span class="p">,</span> numland<span class="p">)</span><span class="o">:</span>
</span><span class='line'>  groupCoords <span class="o">=</span> mmat1.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="p">]</span>.groupby<span class="p">(</span>mmat1.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">3</span><span class="p">])</span>
</span><span class='line'>  transCoords <span class="o">=</span> groupCoords.apply<span class="p">(</span>transScale<span class="p">)</span> <span class="c1">#translate and scale the sample data</span>
</span><span class='line'>  individuals <span class="o">=</span> np.tile<span class="p">(</span>np.arange<span class="p">(</span><span class="m">0</span><span class="p">,</span>numind<span class="p">),</span>numland<span class="p">)</span>
</span><span class='line'>  coordinates <span class="o">=</span> pd.Series<span class="p">((</span>np.arange<span class="p">(</span><span class="m">0</span><span class="p">,</span>numland<span class="p">)</span>.reshape<span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="o">*</span>np.ones<span class="p">(</span>numind<span class="p">)</span>.reshape<span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">-1</span><span class="p">))</span>.flatten<span class="p">())</span>
</span><span class='line'>  transCoords<span class="p">[</span><span class="s">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> coordinates
</span><span class='line'>  transCoords<span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">]</span> <span class="o">=</span> np.sort<span class="p">(</span>individuals<span class="p">)</span>.astype<span class="p">(</span>str<span class="p">)</span>
</span><span class='line'>  <span class="c1">#this part of the code calculates Q-the convergence criterion</span>
</span><span class='line'>  <span class="c1">#that is really the sum of the pairwise squared distances between all shapes in the sample</span>
</span><span class='line'>  <span class="c1">#so that, after rotation these distances are minimized as much as possible</span>
</span><span class='line'>  arrayx <span class="o">=</span> transCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>  arrayy <span class="o">=</span> transCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>  forDist <span class="o">=</span> np.concatenate<span class="p">([</span>arrayx<span class="p">,</span> arrayy<span class="p">],</span> axis <span class="o">=</span> <span class="m">1</span><span class="p">)</span>.reshape<span class="p">(</span>dim<span class="p">,</span>numland<span class="o">*</span>numind<span class="p">)</span>.T
</span><span class='line'>  forDist <span class="o">=</span> forDist.reshape<span class="p">(</span>numind<span class="p">,</span> numland<span class="o">*</span><span class="m">2</span><span class="p">)</span> <span class="c1">#distance function from scipy</span>
</span><span class='line'>  Qm1 <span class="o">=</span> sd.pdist<span class="p">(</span>forDist<span class="p">)</span>
</span><span class='line'>  Q <span class="o">=</span> Qm1.sum<span class="p">()</span>
</span><span class='line'>  <span class="kr">while</span> absolute<span class="p">(</span>Q<span class="p">)</span> <span class="o">&gt;</span> <span class="m">0.00001</span><span class="o">:</span> <span class="c1">#execute the following code until Q cannot be reduced anymore</span>
</span><span class='line'>    groupTrans <span class="o">=</span> transCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="p">]</span>.groupby<span class="p">(</span>transCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">3</span><span class="p">])</span>
</span><span class='line'>    meanShapes <span class="o">=</span> mshapr<span class="p">(</span>transCoords<span class="p">)</span> <span class="c1">#calculate DataFrame of mean shapes excluding one individual at the time</span>
</span><span class='line'>    meanShapes<span class="p">[</span><span class="s">&#39;individuals&#39;</span><span class="p">]</span> <span class="o">=</span> np.sort<span class="p">(</span>individuals<span class="p">)</span>.astype<span class="p">(</span>str<span class="p">)</span>
</span><span class='line'>    meanGroups <span class="o">=</span> meanShapes.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="p">]</span>.groupby<span class="p">(</span>meanShapes.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">2</span><span class="p">])</span>
</span><span class='line'>    tempRot <span class="o">=</span> pd.DataFrame<span class="p">()</span>
</span><span class='line'>    <span class="c1">#following for loop performs partial Procrustes superimposition (pProc function from above) between</span>
</span><span class='line'>    <span class="c1">#mean shapes and each configuration (individual)</span>
</span><span class='line'>    <span class="kr">for</span> ind <span class="kr">in</span> range<span class="p">(</span><span class="m">0</span><span class="p">,</span> numind<span class="p">)</span><span class="o">:</span>
</span><span class='line'>      tosto <span class="o">=</span> pProc<span class="p">(</span>groupTrans.get_group<span class="p">(</span>str<span class="p">(</span>ind<span class="p">)),</span> meanGroups.get_group<span class="p">(</span>str<span class="p">(</span>ind<span class="p">)))</span>
</span><span class='line'>      tempRot <span class="o">=</span> tempRot.append<span class="p">(</span>tosto<span class="p">)</span>
</span><span class='line'>    tempX <span class="o">=</span> tempRot.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>    tempY <span class="o">=</span> tempRot.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>    tempDist <span class="o">=</span> np.concatenate<span class="p">([</span>tempX<span class="p">,</span> tempY<span class="p">],</span> axis <span class="o">=</span> <span class="m">1</span><span class="p">)</span>.reshape<span class="p">(</span>dim<span class="p">,</span>numland<span class="o">*</span>numind<span class="p">)</span>.T
</span><span class='line'>    tempDist <span class="o">=</span> forDist.reshape<span class="p">(</span>numind<span class="p">,</span> numland<span class="o">*</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'>    Qm2 <span class="o">=</span> sd.pdist<span class="p">(</span>tempDist<span class="p">)</span>
</span><span class='line'>    Q <span class="o">=</span> Qm1.sum<span class="p">()</span> <span class="o">-</span> Qm2.sum<span class="p">()</span>
</span><span class='line'>    Qm1 <span class="o">=</span> Qm2 <span class="c1">#re-calculate the convergence criterion at each step</span>
</span><span class='line'>    transCoords <span class="o">=</span> tempRot
</span><span class='line'>  <span class="kr">return</span> tempRot
</span></code></pre></td></tr></table></div></figure>


<p>DataFrame <em>tempRot</em> holds the superimposed configurations (shape variables) that can, subsequently, be used in standard GM analyses and further. Of course, graphical display of superimposition results can be very interesting, and in this post only basic plots will be given, while some of the further posts may include more visualizations. Figure 1 shows the original raw-generated data, Figure 2 the spatial relationships between raw and superimposed data, while Figure 3 shows only superimposed data.</p>

<figure class='code'><figcaption><span>Plotting the data and the relationship of raw and superimposed data</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>procCoords <span class="o">=</span> pGP<span class="p">(</span>allCoords<span class="p">,</span> <span class="m">200</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">10</span><span class="p">)</span> <span class="c1">#perform superimposition</span>
</span><span class='line'>procoordinates <span class="o">=</span> np.tile<span class="p">(</span>np.arange<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">10</span><span class="p">),</span><span class="m">200</span><span class="p">)</span>
</span><span class='line'>procCoords<span class="p">[</span><span class="s">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> procoordinates
</span><span class='line'>meanShape1 <span class="o">=</span> allCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="p">]</span>.groupby<span class="p">(</span>allCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">2</span><span class="p">])</span>.mean<span class="p">()</span> <span class="c1">#calculate mean shape for raw data</span>
</span><span class='line'>meanShape1 <span class="o">=</span> pd.DataFrame<span class="p">(</span>polarRotator<span class="p">(</span>np.array<span class="p">(</span>meanShape1<span class="p">)))</span> <span class="c1">#natural ordering for landmark labels</span>
</span><span class='line'>plt.scatter<span class="p">(</span>allCoords<span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">],</span> allCoords<span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">],</span> s <span class="o">=</span> <span class="m">30</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#82CDFF&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">)</span> <span class="c1">#plot original sampled points</span>
</span><span class='line'>plt.scatter<span class="p">(</span>meanShape1<span class="p">[</span><span class="m">0</span><span class="p">],</span> meanShape1<span class="p">[</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">50</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#7909E8&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>meanShape1<span class="p">[</span><span class="m">0</span><span class="p">],</span> meanShape1<span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#7909E8&quot;</span><span class="p">)</span>
</span><span class='line'>labels <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Landmark {0}&#39;</span>.format<span class="p">(</span>i<span class="p">)</span> <span class="kr">for</span> i <span class="kr">in</span> range<span class="p">(</span><span class="m">10</span><span class="p">)]</span>
</span><span class='line'><span class="kr">for</span> label<span class="p">,</span> x<span class="p">,</span> y <span class="kr">in</span> zip<span class="p">(</span>labels<span class="p">,</span> meanShape1<span class="p">[</span><span class="m">0</span><span class="p">],</span> meanShape1<span class="p">[</span><span class="m">1</span><span class="p">])</span><span class="o">:</span> <span class="c1">#annotate mean landmarks by numbers</span>
</span><span class='line'>  plt.annotate<span class="p">(</span>label<span class="p">,</span> xy <span class="o">=</span> <span class="p">(</span>x<span class="p">,</span> y<span class="m">+0.4</span><span class="p">),</span>ha <span class="o">=</span> <span class="s">&#39;right&#39;</span><span class="p">,</span> va <span class="o">=</span> <span class="s">&#39;bottom&#39;</span><span class="p">)</span>
</span><span class='line'>plt.grid<span class="p">()</span>
</span><span class='line'>meanShape2 <span class="o">=</span> procCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="p">]</span>.groupby<span class="p">(</span>procCoords.iloc<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">2</span><span class="p">])</span>.mean<span class="p">()</span> <span class="c1">#calculate mean shape for superimposed data</span>
</span><span class='line'>meanShape2 <span class="o">=</span> pd.DataFrame<span class="p">(</span>polarRotator<span class="p">(</span>np.array<span class="p">(</span>meanShape2<span class="p">)))</span> <span class="c1">#natural ordering for landmark labels</span>
</span><span class='line'>plt.scatter<span class="p">(</span>procCoords<span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">],</span> procCoords<span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">],</span> s <span class="o">=</span> <span class="m">30</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#FFD699&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">)</span>
</span><span class='line'>plt.scatter<span class="p">(</span>meanShape2<span class="p">[</span><span class="m">0</span><span class="p">],</span> meanShape2<span class="p">[</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">50</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#7909E8&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>meanShape2<span class="p">[</span><span class="m">0</span><span class="p">],</span> meanShape2<span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#7909E8&quot;</span><span class="p">)</span>
</span><span class='line'><span class="kr">for</span> label<span class="p">,</span> x<span class="p">,</span> y <span class="kr">in</span> zip<span class="p">(</span>labels<span class="p">,</span> meanShape2<span class="p">[</span><span class="m">0</span><span class="p">],</span> meanShape2<span class="p">[</span><span class="m">1</span><span class="p">])</span><span class="o">:</span> <span class="c1">#annotate mean landmarks by numbers</span>
</span><span class='line'>  plt.annotate<span class="p">(</span>label<span class="p">,</span> xy <span class="o">=</span> <span class="p">(</span>x<span class="p">,</span> y<span class="m">+0.01</span><span class="p">),</span>ha <span class="o">=</span> <span class="s">&#39;right&#39;</span><span class="p">,</span> va <span class="o">=</span> <span class="s">&#39;bottom&#39;</span><span class="p">)</span>
</span><span class='line'>plt.grid<span class="p">()</span>
</span><span class='line'><span class="c1">#for Figure 2 just plt.scatter of both allCoords and procCoords in the same window</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/rawWithout.png" width="650" height="484" title="'raw generated landmark data'" >
<img class="center" src="http://paulidealiste.github.io/images/originalSuperimposed.png" width="650" height="484" title="'original vs superimposed'" >
<img class="center" src="http://paulidealiste.github.io/images/superWith.png" width="650" height="481" title="'superimposed landmark data'" ></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If using IPython (:)) best way is to paste code with the %paste magic function.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modularity, Graphs and Triangulations]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/05/03/modularity-graphs-and-triangulations/"/>
    <updated>2014-05-03T00:08:25+02:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/05/03/modularity-graphs-and-triangulations</id>
    <content type="html"><![CDATA[<p>Continuing on the previous post, procedures presented here show the comparison between the usual assesment of modularity in the collection of landmarks (same dataset as before) and the depiction of modular structure through graph theory. Usually, modularity in the mammalian cranium is determined a-priori, according to some of the established hypotheses about the developmental origin of cranial elements. One of the most prevalent hypotheses is the two-module organization, one module comprising of elements originating mainly from the neural crest embryonic tissue (anterior cranium) and one comprising of elements with somitomeric origin (posterior cranium). Following code shows the test of this specific hypothesis using <em>geomorph</em> package functions, and additional usage of <em>deldir</em> for visualization of modularity hypotheses.</p>

<figure class='code'><figcaption><span>Importing data, basic GM, modularity and plots</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>library<span class="p">(</span>geomorph<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>deldir<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>ggplot2<span class="p">)</span>
</span><span class='line'>load<span class="p">(</span><span class="s">&quot;capSample.RData&quot;</span><span class="p">)</span>
</span><span class='line'>theme_set<span class="p">(</span>theme_bw<span class="p">())</span>
</span><span class='line'>
</span><span class='line'>capGPA <span class="o">&lt;-</span> gpagen<span class="p">(</span>capSample<span class="p">)</span>
</span><span class='line'>capCoords <span class="o">&lt;-</span> capGPA<span class="o">$</span>coords
</span><span class='line'>mshapeCap <span class="o">&lt;-</span> mshape<span class="p">(</span>capCoords<span class="p">)</span> <span class="c1">#mean shape is useful for plotting </span>
</span><span class='line'>
</span><span class='line'><span class="c1">#vector depicting the division of landmarks according to modularity </span>
</span><span class='line'>modularity1.gps <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#test for modularity based on the RV coefficient</span>
</span><span class='line'>modularity1 <span class="o">&lt;-</span> compare.modular.partitions<span class="p">(</span>capCoords<span class="p">,</span> landgroups <span class="o">=</span> modularity1.gps<span class="p">)</span>
</span><span class='line'><span class="c1">#plot of landmark membership to a-priori modules</span>
</span><span class='line'>deldir<span class="p">(</span>mshapeCap<span class="p">[,</span><span class="m">1</span><span class="p">],</span> mshapeCap<span class="p">[,</span><span class="m">2</span><span class="p">],</span> plotit <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> wlines <span class="o">=</span> <span class="s">&quot;triang&quot;</span><span class="p">,</span> xlim <span class="o">=</span> c<span class="p">(</span><span class="m">-0.2</span><span class="p">,</span><span class="m">0.55</span><span class="p">))</span>
</span><span class='line'>points<span class="p">(</span>mshapeCap<span class="p">[</span>c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">8</span><span class="p">,</span><span class="m">11</span><span class="p">),</span><span class="m">1</span><span class="p">],</span> mshapeCap<span class="p">[</span>c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">8</span><span class="p">,</span><span class="m">11</span><span class="p">),</span><span class="m">2</span><span class="p">],</span> col <span class="o">=</span> <span class="s">&quot;#FF8740&quot;</span><span class="p">,</span> pch <span class="o">=</span> <span class="m">19</span><span class="p">,</span> cex <span class="o">=</span> <span class="m">1.2</span><span class="p">)</span>
</span><span class='line'>points<span class="p">(</span>mshapeCap<span class="p">[</span>c<span class="p">(</span><span class="m">9</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="m">12</span><span class="o">:</span><span class="m">16</span><span class="p">),</span><span class="m">1</span><span class="p">],</span> mshapeCap<span class="p">[</span>c<span class="p">(</span><span class="m">9</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="m">12</span><span class="o">:</span><span class="m">16</span><span class="p">),</span><span class="m">2</span><span class="p">],</span> col <span class="o">=</span> <span class="s">&quot;#61B4CF&quot;</span><span class="p">,</span> pch <span class="o">=</span> <span class="m">19</span><span class="p">,</span> cex <span class="o">=</span> <span class="m">1.2</span><span class="p">)</span>
</span><span class='line'>legend<span class="p">(</span><span class="m">0.2</span><span class="p">,</span><span class="m">0.4</span><span class="p">,</span> legend <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;neural crest&quot;</span><span class="p">,</span> <span class="s">&quot;somitomere&quot;</span><span class="p">),</span> fill <span class="o">=</span> colormap<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Figure 1 shows the theoretical distribution of the RV coefficients, calculated for all posible two-module subdivisions of landmarks, as well as the observed RV value from the hypothesis depicted in Figure 2. Since the observed value is lower than most of the hypothetic values, then it could be said that this modularity hypothesis stands.</p>

<p><img class="center" src="http://paulidealiste.github.io/images/RVmodularity.png" width="570" height="497" title="'RV coefficients'" >
<img class="center" src="http://paulidealiste.github.io/images/modularityLand.png" width="344" height="376" title="'Modularity hypothesis'" ></p>

<p>The idea for using graph theory representation and analysis of modularity is based on correlation matrix, same one from the previous post. Correlation matrix was obtained through Delaunay triangulation and every vertex (node) in the graph actually represents the 1/3 of the total area of all Delaunay triangles emanating from the corresponding landmark.</p>

<figure class='code'><figcaption><span>Delaunay triangulation and derivation of the correlation matrix</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>cicoCap <span class="o">&lt;-</span> t<span class="p">(</span>apply<span class="p">(</span>capCoords<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="kr">function</span><span class="p">(</span>A<span class="p">)</span> deldir<span class="p">(</span>A<span class="p">[,</span><span class="m">1</span><span class="p">],</span>A<span class="p">[,</span><span class="m">2</span><span class="p">])</span><span class="o">$</span>summary<span class="p">[,</span><span class="m">4</span><span class="p">]))</span>
</span><span class='line'>cicoCap <span class="o">&lt;-</span> data.frame<span class="p">(</span>cicoCap<span class="p">)</span>
</span><span class='line'>names<span class="p">(</span>cicoCap<span class="p">)</span> <span class="o">&lt;-</span> paste<span class="p">(</span><span class="s">&quot;lm&quot;</span><span class="p">,</span> c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">16</span><span class="p">),</span> sep <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>capCor <span class="o">&lt;-</span> abs<span class="p">(</span>cor<span class="p">(</span>cicoCap<span class="p">))</span> <span class="c1">#correlation matrix</span>
</span><span class='line'>diag<span class="p">(</span>capCor<span class="p">)</span> <span class="o">&lt;-</span> <span class="m">0</span> <span class="c1">#diagonals must be set to zero</span>
</span></code></pre></td></tr></table></div></figure>


<p>Graph based on the correlation matrix can be created and manipulated with the wonderful <em>igraph</em> package. Vertices of this graph will be abovementioned areas, while the edges will represent correlation (edge weights) between areas around each landmark. According to weights, edges can be colored and the strength of thier lines increased, so that the most correlated landmarks wolud be more obvious.</p>

<figure class='code'><figcaption><span>iGraph graph creation and manipulation</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>graph <span class="o">&lt;-</span> graph.adjacency<span class="p">(</span>capCor<span class="p">,</span> weighted<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span> mode<span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">)</span>
</span><span class='line'>E<span class="p">(</span>graph<span class="p">)[</span> weight <span class="o">&gt;</span> <span class="m">0.5</span> <span class="p">]</span><span class="o">$</span>color <span class="o">&lt;-</span> <span class="s">&quot;#A63E00&quot;</span>
</span><span class='line'>E<span class="p">(</span>graph<span class="p">)[</span> weight <span class="o">&gt;</span> <span class="m">0.5</span> <span class="p">]</span><span class="o">$</span>width <span class="o">&lt;-</span> <span class="m">3.6</span>
</span><span class='line'>E<span class="p">(</span>graph<span class="p">)[</span> weight <span class="o">&gt;</span> <span class="m">-0.5</span> <span class="o">&amp;</span> weight <span class="o">&lt;</span> <span class="m">0.5</span> <span class="p">]</span><span class="o">$</span>color <span class="o">&lt;-</span> <span class="s">&quot;#D6EBFF&quot;</span>
</span><span class='line'>E<span class="p">(</span>graph<span class="p">)[</span> weight <span class="o">&gt;</span> <span class="m">-0.5</span> <span class="o">&amp;</span> weight <span class="o">&lt;</span> <span class="m">0.5</span> <span class="p">]</span><span class="o">$</span>width <span class="o">&lt;-</span> <span class="m">1.2</span>
</span></code></pre></td></tr></table></div></figure>


<p>Modularity, or community structure in the graph theory represents the degree of compartmentalization in the graph structure, based on the spatial relationship or the weights of graph edges. Although, a-priori subdivision of graph vertices is possible, and the evaluation of such graph community can be easily done, the advantage of graph theory for modularity is the availability of algorithms for searching the community structure, so it can derive subdivsion a-posteriori, that can be compared to the hypothesis from Figure 1.</p>

<figure class='code'><figcaption><span>Graph modularity and plotting</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>gsc <span class="o">&lt;-</span> leading.eigenvector.community<span class="p">(</span>graph<span class="p">,</span> weights <span class="o">=</span> E<span class="p">(</span>graph<span class="p">)</span><span class="o">$</span>weights<span class="p">)</span>
</span><span class='line'>modularity<span class="p">(</span>graph<span class="p">,</span> membership<span class="p">(</span>gsc<span class="p">))</span>
</span><span class='line'>colormap <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;#FF8740&quot;</span><span class="p">,</span> <span class="s">&quot;#61B4CF&quot;</span><span class="p">)</span>
</span><span class='line'>V<span class="p">(</span>graph<span class="p">)</span><span class="o">$</span>color <span class="o">&lt;-</span> colormap<span class="p">[</span>gsc<span class="o">$</span>membership<span class="p">]</span> <span class="c1">#color graph vertices according to community</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#graph layout will be circular since values for the edges range from 0.2 to 0.9, </span>
</span><span class='line'><span class="c1">#and they all form similar attractive force between the vertices.</span>
</span><span class='line'>graph<span class="o">$</span>layout <span class="o">&lt;-</span> layout.fruchterman.reingold <span class="c1">#really no effect on the shape of this graph</span>
</span><span class='line'>
</span><span class='line'>plot<span class="p">(</span>graph<span class="p">,</span> vertex.size <span class="o">=</span> <span class="m">20</span><span class="p">,</span> vertex.shape <span class="o">=</span> <span class="s">&quot;circle&quot;</span><span class="p">)</span>
</span><span class='line'>legend<span class="p">(</span><span class="m">0.8</span><span class="p">,</span><span class="m">1.4</span><span class="p">,</span> legend <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;neural crest&quot;</span><span class="p">,</span> <span class="s">&quot;somitomere&quot;</span><span class="p">),</span> fill <span class="o">=</span> colormap<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Leading eigenvector community algorithm tries to find community structure in the graph by calculating the eigenvector of the modularity matrix for the largest positive eigenvalue and then separating vertices into two communities based on the sign of the corresponding element in the eigenvector (Newman, 2006<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>). This method was preffered over many others because it is closer to usual multivariate methods, such as PCA, that are commonly used to depict variability patterns.</p>

<p><img class="center" src="http://paulidealiste.github.io/images/modularityGraph.png" width="541" height="467" title="'Modularity graph'" ></p>

<p>Graph community strucure depicts modularity in the landmark configurations accurately, with the exception of lm16, that is positioned on the posterior basicranium. Higher correlations are, on average, present within modules while between modules, only one connection is higher than 0.5, that between lm2 and lm14. Since these landmarks lay on the opposite sides of the cranium, they may encompass the variability in total anterior-posterior length. i.e. cranial size.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Newman, M.E.J. 2006. Modularity and community structure in networks. <em>PNAS</em> <strong>103</strong>: 8577-8582.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Delaunay Triangulation Experiment]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/04/04/delaunay-triangulation-for-modularity-pt-1/"/>
    <updated>2014-04-04T18:09:37+02:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/04/04/delaunay-triangulation-for-modularity-pt-1</id>
    <content type="html"><![CDATA[<p>Since landmark data consists of x and y Cartesian coordinates, it would be useful if they could be represented by one summary number, that would preserve the spatial information. This is just a proposal of one possiblity using Delaunay triangulation between landmark configurations, and the average area of all triangles emanating from individual landmarks. Since landmark position within the triangulation grid would influence the shape and size as well as number of triangles around it, the area should preserve enoguh information about the spatial relationships of landmarks. Dataset for this post consists of ventral aspect half configurations from <a href="http://goo.gl/LP3xsd" target="_blank">here</a>. Delaunay triangulation will be performed using <em>deldir</em> R package, since it reports the mentioned triangle areas as a part of object summary.</p>

<figure class='code'><figcaption><span>Importing data, basic GM, calculating the triangulation, extracting areas and plotting</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>library<span class="p">(</span>deldir<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>geomorph<span class="p">)</span>
</span><span class='line'>load<span class="p">(</span><span class="s">&quot;capSample.RData&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>capreolusGPA <span class="o">&lt;-</span> gpagen<span class="p">(</span>capSample<span class="p">)</span>
</span><span class='line'>capGPAcoords <span class="o">&lt;-</span> capreolusGPA<span class="o">$</span>coords
</span><span class='line'>
</span><span class='line'>delCap <span class="o">&lt;-</span> deldir<span class="p">(</span>capSample<span class="p">[,,</span><span class="m">10</span><span class="p">][,</span><span class="m">1</span><span class="p">],</span> capSample<span class="p">[,,</span><span class="m">10</span><span class="p">][,</span><span class="m">2</span><span class="p">])</span> <span class="c1">#extract any individual from an array for visualization</span>
</span><span class='line'>plot<span class="p">(</span>delCap<span class="p">,</span> col<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;lightblue&quot;</span><span class="p">,</span><span class="s">&quot;lightgrey&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">),</span> lwd <span class="o">=</span> c<span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">),</span> xlim <span class="o">=</span> c<span class="p">(</span><span class="m">150</span><span class="p">,</span> <span class="m">400</span><span class="p">),</span> cex <span class="o">=</span> <span class="m">0.1</span><span class="p">,</span> ann <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span><span class='line'>points<span class="p">(</span>capSample<span class="p">[,,</span><span class="m">10</span><span class="p">],</span> col <span class="o">=</span> <span class="s">&quot;orange&quot;</span><span class="p">,</span> pch <span class="o">=</span> <span class="m">16</span><span class="p">,</span> cex <span class="o">=</span> <span class="m">1.4</span><span class="p">)</span>
</span><span class='line'>text<span class="p">(</span>capSample<span class="p">[,,</span><span class="m">10</span><span class="p">],</span> label <span class="o">=</span> c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">16</span><span class="p">),</span> pos <span class="o">=</span> <span class="m">3</span><span class="p">,</span> ceo <span class="o">=</span> <span class="m">0.5</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>areaCap <span class="o">&lt;-</span> t<span class="p">(</span>apply<span class="p">(</span>capGPAcoords<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="kr">function</span><span class="p">(</span>A<span class="p">)</span> deldir<span class="p">(</span>A<span class="p">[,</span><span class="m">1</span><span class="p">],</span>A<span class="p">[,</span><span class="m">2</span><span class="p">])</span><span class="o">$</span>summary<span class="p">[,</span><span class="m">4</span><span class="p">]))</span> <span class="c1">#calcuate areas per landmark</span>
</span><span class='line'>areaCap <span class="o">&lt;-</span> data.frame<span class="p">(</span>areaCap<span class="p">)</span>
</span><span class='line'>names<span class="p">(</span>areaCap<span class="p">)</span> <span class="o">&lt;-</span> paste<span class="p">(</span><span class="s">&quot;lm&quot;</span><span class="p">,</span> c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">16</span><span class="p">),</span> sep <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/Delaunay.png" width="401" height="473" title="'Delaunay'" ></p>

<p>Values in the areaCap matrix represent average areas of all triangles emanating from the landmark in question, so its dimensions are 60x16. Correlation matrix (16x16) can be calculated from the areaCap matrix, and it should reflect relative positioning of landmarks through spatial grouping pattern. This can be checked visually using <em>corrplot</em> package visualization of the correlation matrix, which allows direct assesment of emerging patterns in the matrix. Additionally, this package allows reordering of rows and columns according to hierarchical clustering algorhithms and representing the desired number of clusters with rectangles in the correlation plot. This can only be considered as an idea of general modularity, since landmarks from the same cranial region should be correlated more than distant landmarks. But the transformation of xy coordinates to average triangle areas may have introduced non-biological variation or obscured some of the natural variation and these procedures as well as subsequent analyses may be treated only as a fun experiment and visualization tool for now.</p>

<figure class='code'><figcaption><span>Drawing correlation plot</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>library<span class="p">(</span>corrplot<span class="p">)</span>
</span><span class='line'>capCor <span class="o">&lt;-</span> cor<span class="p">(</span>areaCap<span class="p">)</span>
</span><span class='line'>corrplot<span class="p">(</span>capCor<span class="p">,</span> method <span class="o">=</span> <span class="s">&quot;circle&quot;</span><span class="p">,</span> tl.cex <span class="o">=</span> <span class="m">0.93</span><span class="p">,</span> order <span class="o">=</span> <span class="s">&quot;hclust&quot;</span><span class="p">,</span> addrect <span class="o">=</span> <span class="m">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/Corrplot.png" width="570" height="529" title="'Delaunay'" ></p>

<p>Correlation plot with three proposed general landmark groups in the matrix reveals that the correlations are, on average, higher for locally grouped landmaks, especially the anterior ones, from 1 to 7. This can`t be used as a reliablie test for modularity hypothesis, but it can serve as a basis for further analyses based on construcing linked graphs or networks using correlation matrices from landmark data, where the xy coordinates are transformed to one number. Also this can be a useful way of representing modular structure visually, since both Delaunay and correlation plots are highly customizable, and can be colored according to real modularity hypotheses. Testing some of these will be the subject of future posts.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extracting Climate Data in R]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/03/27/extracting-climate-data-in-r/"/>
    <updated>2014-03-27T19:44:55+01:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/03/27/extracting-climate-data-in-r</id>
    <content type="html"><![CDATA[<p>With the ongoing expand of the available geospatial databases in raster format (GeoTiff) it is getting easier to analyse the relationship between any complex morphology, captured in landmark data, and i.e. climate or precipitation data with the help of partial least squares (PLS). R has a wonderful <em>raser</em>, <em>sp</em> and <em>gdal</em> packages that facilitate the extraction of the geospatial data from GeoTiff raster grids. In this post the geoTiff used will be from the <a href="http://www.worldclim.org/" target="_blank">WorldClim</a> website, and the climate data for European square 16, where some of my real samples originate from. In order to get this data you can follow the downloads section of the WorldClim website and choose download data by tile, 30 arc-seconds resolution. When a map opens the dataset for this post would be under the map, when clicked on the square zone 16 and finally download the Mean Temperature. This is a .zip file with twelve GeoTiffs, one for each month. Unpack the files in a pre-destined directory, and declare this a working directory in the R session.</p>

<figure class='code'><figcaption><span>Importing libraries, reading and inital plots of the GeoTiff data</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>setwd<span class="p">(</span><span class="s">&quot;~/tmean&quot;</span><span class="p">)</span> <span class="c1">#this is the folder with all the GeoTiffs</span>
</span><span class='line'>library<span class="p">(</span>raster<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>sp<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>rgdal<span class="p">)</span>
</span><span class='line'>meanJan <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean1_16.tif&quot;</span><span class="p">)</span> <span class="c1">#mean temp for January etc.</span>
</span><span class='line'>meanFeb <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean2_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanMar <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean3_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanApr <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean4_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanMaj <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean5_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanJun <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean6_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanJul <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean7_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanAvg <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean8_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanSep <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean9_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanOkt <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean10_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanNov <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean11_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>meanDec <span class="o">&lt;-</span> raster<span class="p">(</span><span class="s">&quot;tmean12_16.tif&quot;</span><span class="p">)</span>
</span><span class='line'>plot<span class="p">(</span>meanJan<span class="p">)</span> <span class="c1">#will simply get the basic R plot of a GeoTiff raster</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<img class="center" src="http://paulidealiste.github.io/images/meanJan.png" width="521" height="410" title="'mean january'" ></p>

<p>After reading in the basic data, <em>raster</em> package offers several formats in which to keep the data, besides the basic raster. The most useful one is a raster stack which really is just the piled-up rasters that can be manipulated together. Also one useful visual help is the addition of the country boundaries followed by zooming in to the extent of the country or region where the samples originate from. Country boundaries .shp files is freely avalilable from <a href="http://thematicmapping.org/downloads/world_borders.php" target="_blank">thematicmapping</a>. When downloaded they should be in the same directory as the GeoTiffs.</p>

<figure class='code'><figcaption><span>Creating the raster stack, adding boundaries and zooming to an extent</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>mtStack <span class="o">&lt;-</span> stack<span class="p">(</span>meanJan<span class="p">,</span> meanFeb<span class="p">,</span> meanMar<span class="p">,</span> meanApr<span class="p">,</span> meanMaj<span class="p">,</span> meanJun<span class="p">,</span> meanJul<span class="p">,</span> meanAvg<span class="p">,</span> meanSep<span class="p">,</span> meanOkt<span class="p">,</span> meanNov<span class="p">,</span> meanDec<span class="p">)</span>
</span><span class='line'>bounds <span class="o">&lt;-</span> readOGR<span class="p">(</span>dsn<span class="o">=</span>getwd<span class="p">(),</span> layer<span class="o">=</span> <span class="s">&quot;TM_WORLD_BORDERS-0.3&quot;</span><span class="p">)</span> <span class="c1">#import borders</span>
</span><span class='line'>plot<span class="p">(</span>meanJan<span class="p">)</span> <span class="c1">#plot the raster file for any month</span>
</span><span class='line'>extentR <span class="o">&lt;-</span> drawExtent<span class="p">()</span>
</span><span class='line'><span class="c1">#drawExtent enters the interactive mode where you can draw the polygon for zooming based on two points, top right and lower left</span>
</span><span class='line'><span class="c1">#values in extentR are coordinates in WGS84 datum and expressed as longitude data</span>
</span><span class='line'>plot<span class="p">(</span>zoom<span class="p">(</span>bounds<span class="p">,</span> extentR<span class="p">),</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span><span class='line'><span class="c1">#unfortunately this does not work well since it will plot the bounds in the zoom extent</span>
</span><span class='line'><span class="c1">#and if the both raster and bounds are needed then it might be ok to overlap them in GIMP</span>
</span><span class='line'>plot<span class="p">(</span>zoom<span class="p">(</span>meanJan<span class="p">,</span> extentR<span class="p">),</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/zoomara.png" width="519" height="414" title="'mean january zoomed'" ></p>

<p>Before final extraction of the climate data it can be useful to plot each month`s mean temperature for the selected extent of the rasater. This can be easily achieved by using the <em>rasterVis</em> package levelplot and the extentR variable, which can be used to cut through all raster layers in the stack.</p>

<figure class='code'><figcaption><span>Cutting the stack and drawing levelplot for all months</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>library<span class="p">(</span>rasterVis<span class="p">)</span>
</span><span class='line'>cutStack <span class="o">&lt;-</span> <span class="p">(</span>crop<span class="p">(</span>mtStack<span class="p">,</span> extentR<span class="p">))</span><span class="o">/</span><span class="m">10</span>
</span><span class='line'><span class="c1">#division by 10 is needed since the temperature data in this GeoTiff is x10 for saving memory-important</span>
</span><span class='line'>names<span class="p">(</span>cutStack<span class="p">)</span> <span class="o">&lt;-</span> month.abb
</span><span class='line'>levelplot<span class="p">(</span>cutStack<span class="p">)</span> <span class="c1">#may take long time to plot</span>
</span><span class='line'>histogram<span class="p">(</span>cutStack<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/meanLevel1.png" width="570" height="467" title="'mean all'" >
<img class="center" src="http://paulidealiste.github.io/images/meanLevel2.png" width="570" height="467" title="'mean all h'" ></p>

<p>Slightly more efficient than the drawExtent is the spatialPolygons function from the <em>sp</em> package that will be used for definition of the real sampling localities, by simply drawing boundaries of the localities by hand or using the known positional data. It is best if approximate latitude/longitude coordinates are known in advance so that the defining polygon can be drawn connecting several corners-points, that form the broader sampling area border. If coordinates are not known in advance then the drawExtent should be used first for finding the latitude/longitude of the spatial polygon points, and then making the SpatialPolygon object out of them, as described next.</p>

<figure class='code'><figcaption><span>Extracting spatialPolygons by latitude/longitude pairs </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>taraCoord <span class="o">&lt;-</span> rbind<span class="p">(</span>c<span class="p">(</span><span class="m">19.241867</span><span class="p">,</span> <span class="m">44.012571</span><span class="p">),</span> c<span class="p">(</span><span class="m">19.351730</span><span class="p">,</span> <span class="m">43.976511</span><span class="p">),</span> c<span class="p">(</span><span class="m">19.518585</span><span class="p">,</span> <span class="m">43.923121</span><span class="p">),</span> c<span class="p">(</span><span class="m">19.435501</span><span class="p">,</span> <span class="m">43.894924</span><span class="p">),</span> c<span class="p">(</span><span class="m">19.317398</span><span class="p">,</span> <span class="m">43.896903</span><span class="p">),</span> c<span class="p">(</span><span class="m">19.261780</span><span class="p">,</span> <span class="m">43.955259</span><span class="p">),</span> c<span class="p">(</span><span class="m">19.241867</span><span class="p">,</span> <span class="m">44.012571</span><span class="p">))</span>
</span><span class='line'>R1Coord <span class="o">&lt;-</span> rbind<span class="p">(</span>c<span class="p">(</span><span class="m">24.656067</span><span class="p">,</span> <span class="m">45.627484</span><span class="p">),</span> c<span class="p">(</span><span class="m">25.252075</span><span class="p">,</span> <span class="m">45.575600</span><span class="p">),</span> c<span class="p">(</span><span class="m">25.628357</span><span class="p">,</span> <span class="m">45.525592</span><span class="p">),</span> c<span class="p">(</span><span class="m">25.488281</span><span class="p">,</span> <span class="m">45.3000007</span><span class="p">),</span> c<span class="p">(</span><span class="m">25.046082</span><span class="p">,</span> <span class="m">45.381080</span><span class="p">),</span> c<span class="p">(</span><span class="m">24.672546</span><span class="p">,</span> <span class="m">45.539060</span><span class="p">),</span> c<span class="p">(</span><span class="m">24.656067</span><span class="p">,</span> <span class="m">45.627484</span><span class="p">))</span>
</span><span class='line'><span class="c1">#these objects are matrices with two columns, one for latitude of a polygon corner and the other the longitude</span>
</span><span class='line'>polyTara <span class="o">&lt;-</span> SpatialPolygons<span class="p">(</span>list<span class="p">(</span>Polygons<span class="p">(</span>list<span class="p">(</span>Polygon<span class="p">(</span>taraCoord<span class="p">)),</span> <span class="m">1</span><span class="p">)))</span> <span class="c1">#declare object type</span>
</span><span class='line'>polyR1 <span class="o">&lt;-</span> SpatialPolygons<span class="p">(</span>list<span class="p">(</span>Polygons<span class="p">(</span>list<span class="p">(</span>Polygon<span class="p">(</span>R1Coord<span class="p">)),</span> <span class="m">1</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>After all spatial polygons are defined, final step involves the extraction of the mean temperature values from the points encircled by the polygon in question, for all months. Since GeoTiffs are raster formats, they are carrying the information on the temperature in the points of the bitmap grid, so if the polygon is too small, small will be the number of the grid-points inside, maybe smaller than the number of individuals. To avoid this make sampling area broader, and in this case polyTara has some 220 individual grid points inside, which means 220 values for the mean temperature in the area. If we have i.e. ten individuals per population it is necessery to have also 10 mean temperature values, so that both blocks in subsequent PLS would have same dimensionality. R`s basic sample function can be used to extract random values from the i.e. 220 points within the population (Tara and R1) polygons. This simulates random sampling of individuals from the sampling locality and after that any analysis can be done, from linear models to PLS, which will be shown in future posts.</p>

<figure class='code'><figcaption><span>Extracting climate data and preparing the dataset according to the number of individuals</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>matTaraMean <span class="o">&lt;-</span> extract<span class="p">(</span>cutStack<span class="p">,</span> polyTara<span class="p">)[[</span><span class="m">1</span><span class="p">]]</span>
</span><span class='line'>matR1Mean <span class="o">&lt;-</span> extract<span class="p">(</span>cutStack<span class="p">,</span> polyR1<span class="p">)[[</span><span class="m">1</span><span class="p">]]</span>
</span><span class='line'>plot<span class="p">(</span>cutStack<span class="o">$</span>Jan<span class="p">)</span>
</span><span class='line'>plot<span class="p">(</span>polyTara<span class="p">,</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span><span class='line'>plot<span class="p">(</span>polyR1<span class="p">,</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span><span class='line'>n <span class="o">&lt;-</span> dim<span class="p">(</span>matTaraMean<span class="p">)[</span><span class="m">1</span><span class="p">]</span> <span class="c1">#for sampling convenience</span>
</span><span class='line'>m <span class="o">&lt;-</span> dim<span class="p">(</span>matR1Mean<span class="p">)[</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>taraMat <span class="o">&lt;-</span> matTaraMean<span class="p">[</span>sample<span class="p">(</span>n<span class="p">,</span> <span class="m">10</span><span class="p">),]</span> <span class="c1">#this is the final extracted data</span>
</span><span class='line'>R1Mat <span class="o">&lt;-</span> matR1Mean<span class="p">[</span>sample<span class="p">(</span>m<span class="p">,</span> <span class="m">10</span><span class="p">),]</span>
</span><span class='line'>library<span class="p">(</span>ggplot2<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>reshape2<span class="p">)</span>
</span><span class='line'>plotter <span class="o">&lt;-</span> data.frame<span class="p">(</span>rbind<span class="p">(</span>taraMat<span class="p">,</span> R1Mat<span class="p">),</span> loc <span class="o">=</span> c<span class="p">(</span>rep<span class="p">(</span><span class="s">&quot;Ta&quot;</span><span class="p">,</span><span class="m">10</span><span class="p">),</span> rep<span class="p">(</span><span class="s">&quot;R1&quot;</span><span class="p">,</span> <span class="m">10</span><span class="p">)))</span> <span class="c1">#for ggplot2</span>
</span><span class='line'>forplo <span class="o">&lt;-</span> melt<span class="p">(</span>plotter<span class="p">)</span>
</span><span class='line'>m <span class="o">&lt;-</span> ggplot<span class="p">(</span>forplo<span class="p">,</span> aes<span class="p">(</span>x <span class="o">=</span> value<span class="p">,</span> fill <span class="o">=</span> loc<span class="p">))</span> <span class="o">+</span> geom_histogram<span class="p">()</span> <span class="o">+</span> facet_grid<span class="p">(</span>variable<span class="o">~</span>.<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Figure 5. shows the locations of tara and R1 spatial polygons within the zoomed extent of the zone 16, while in Figure 6. barplots are shown for 10 random points for all months, and for both localities, for comparison.</p>

<p><img class="center" src="http://paulidealiste.github.io/images/Fig5climate.png" width="536" height="433" title="'localities'" >
<img class="center" src="http://paulidealiste.github.io/images/Fig6climate.png" width="802" height="700" title="'histograms'" ></p>

<p>It is obvious that the Tara locality has higer mean monthly temperature, on average for every month, and also it has less temperature variaton than R1.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Forcing Monsters` Shape]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/03/08/python-forcing-monsters%60-shape/"/>
    <updated>2014-03-08T11:49:21+01:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/03/08/python-forcing-monsters`-shape</id>
    <content type="html"><![CDATA[<p>Continuing on one of the previous posts about data generation in python, next natural step in the analytic procedure is the Procrustes superimposition. Since this procedure enables direct analyses of configurations` shape, and all subsequent explorative visualizations, it must be employed first. This post concerns with the basic superimposition procedure, involving only two landmark configurations, i.e. two generated monsters. One monster will be used as a reference and one as a target, which should undergo superimposition. First steps in data genration are the same as before, with the exception of polarRotator function that can take any numpy array and reorder it according to polar rotation angle. This is very useful since generated landmarks are not ordered properly and do not &ldquo;feel natural&rdquo; in plots and analyses.</p>

<figure class='code'><figcaption><span>Library import, data generation and some functions</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>import numpy as np
</span><span class='line'>import pandas as pd
</span><span class='line'>import matplotlib.pyplot as plt
</span><span class='line'>
</span><span class='line'>def centsize<span class="p">(</span>M<span class="p">)</span><span class="o">:</span>   <span class="c1">#centroid size of any configuration matrix</span>
</span><span class='line'>  p <span class="o">=</span> M.shape<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>  csize <span class="o">=</span> np.sqrt<span class="p">(</span>np.sum<span class="p">(</span>M.var<span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="o">*</span><span class="p">(</span>p<span class="m">-1</span><span class="p">))</span>
</span><span class='line'>  <span class="kr">return</span> csize
</span><span class='line'>
</span><span class='line'>def polarRotator<span class="p">(</span>M<span class="p">)</span><span class="o">:</span>   <span class="c1">#polar rotation for natural ordering of landmarks</span>
</span><span class='line'>  x <span class="o">=</span> np.array<span class="p">(</span>M<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">])</span>
</span><span class='line'>  y <span class="o">=</span> np.array<span class="p">(</span>M<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">])</span>
</span><span class='line'>  points <span class="o">=</span> np.array<span class="p">((</span>x<span class="p">,</span>y<span class="p">))</span>.T
</span><span class='line'>  cent <span class="o">=</span> <span class="p">(</span>np.sum<span class="p">(</span>x<span class="p">)</span><span class="o">/</span>len<span class="p">(</span>M<span class="p">),</span> np.sum<span class="p">(</span>y<span class="p">)</span><span class="o">/</span>len<span class="p">(</span>M<span class="p">))</span>
</span><span class='line'>  angle <span class="o">=</span> np.arctan2<span class="p">(</span>points<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span><span class="o">-</span>cent<span class="p">[</span><span class="m">1</span><span class="p">],</span>points<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span><span class="o">-</span>cent<span class="p">[</span><span class="m">0</span><span class="p">])</span>
</span><span class='line'>  points <span class="o">=</span> pd.DataFrame<span class="p">(</span>points<span class="p">,</span> columns <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'>  angle <span class="o">=</span> pd.Series<span class="p">(</span>angle<span class="p">)</span>
</span><span class='line'>  points<span class="p">[</span><span class="s">&#39;angle&#39;</span><span class="p">]</span> <span class="o">=</span> angle
</span><span class='line'>  points <span class="o">=</span> points.sort<span class="p">(</span><span class="s">&#39;angle&#39;</span><span class="p">)</span>
</span><span class='line'>  rotatedMat <span class="o">=</span> np.array<span class="p">(</span>points<span class="p">[[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">]])</span>
</span><span class='line'>  <span class="kr">return</span> rotatedMat
</span><span class='line'>
</span><span class='line'>coordstest <span class="o">=</span> np.vstack<span class="p">([</span>np.random.uniform<span class="p">(</span><span class="m">175</span><span class="p">,</span> <span class="m">220</span><span class="p">,</span> <span class="m">10</span><span class="p">),</span> np.random.uniform<span class="p">(</span><span class="m">175</span><span class="p">,</span> <span class="m">220</span><span class="p">,</span> <span class="m">10</span><span class="p">)])</span>.T
</span><span class='line'>monster1 <span class="o">=</span> np.vstack<span class="p">([</span>np.random.multivariate_normal<span class="p">(</span>coordstest<span class="p">[</span>i<span class="p">,</span><span class="o">:</span><span class="p">],</span> <span class="p">[[</span><span class="m">3</span><span class="p">,</span><span class="m">0</span><span class="p">],[</span><span class="m">0</span><span class="p">,</span><span class="m">3</span><span class="p">]],</span> <span class="m">1</span><span class="p">)</span> <span class="kr">for</span> i <span class="kr">in</span> range<span class="p">(</span><span class="m">10</span><span class="p">)])</span>
</span><span class='line'>monster2 <span class="o">=</span> np.vstack<span class="p">([</span>np.random.multivariate_normal<span class="p">(</span>coordstest<span class="p">[</span>i<span class="p">,</span><span class="o">:</span><span class="p">],</span> <span class="p">[[</span><span class="m">3</span><span class="p">,</span><span class="m">0</span><span class="p">],[</span><span class="m">0</span><span class="p">,</span><span class="m">3</span><span class="p">]],</span> <span class="m">1</span><span class="p">)</span> <span class="kr">for</span> i <span class="kr">in</span> range<span class="p">(</span><span class="m">10</span><span class="p">)])</span>
</span><span class='line'>
</span><span class='line'>monster1 <span class="o">=</span> polarRotator<span class="p">(</span>monster1<span class="p">)</span>
</span><span class='line'>monster2 <span class="o">=</span> polarRotator<span class="p">(</span>monster2<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The plot of configurations reveals their spatial relationship, as well as the general mean shape. This time, since landmarks are ordered properly, one line would be enough for representing mean shapes, and shapes of respective configurations.</p>

<figure class='code'><figcaption><span>Plotting the original monsters</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>plt.scatter<span class="p">(</span>monster1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> monster1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">80</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#FFD200&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> label <span class="o">=</span> <span class="s">&quot;monster1&quot;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>monster1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> monster1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;--&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#FFD200&quot;</span><span class="p">)</span>
</span><span class='line'>plt.scatter<span class="p">(</span>monster2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> monster2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">80</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#47BFDD&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> label <span class="o">=</span> <span class="s">&quot;monster2&quot;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>monster2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> monster2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;--&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#47BFDD&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>meanMon <span class="o">=</span> <span class="p">(</span>monster1 <span class="o">+</span> monster2<span class="p">)</span> <span class="o">/</span> <span class="m">2</span> <span class="c1">#calculate mean shape</span>
</span><span class='line'>plt.scatter<span class="p">(</span>meanMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> meanMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">90</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#6a12c4&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> label <span class="o">=</span> <span class="s">&quot;mean monster&quot;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>meanMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> meanMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#6a12c4&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>labels <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Landmark {0}&#39;</span>.format<span class="p">(</span>i<span class="p">)</span> <span class="kr">for</span> i <span class="kr">in</span> range<span class="p">(</span><span class="m">10</span><span class="p">)]</span>
</span><span class='line'><span class="kr">for</span> label<span class="p">,</span> x<span class="p">,</span> y <span class="kr">in</span> zip<span class="p">(</span>labels<span class="p">,</span> meanMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> meanMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">])</span><span class="o">:</span> <span class="c1">#annotate mean landmarks by numbers</span>
</span><span class='line'>  plt.annotate<span class="p">(</span>label<span class="p">,</span> xy <span class="o">=</span> <span class="p">(</span>x<span class="p">,</span> y<span class="m">+0.3</span><span class="p">),</span> ha <span class="o">=</span> <span class="s">&#39;right&#39;</span><span class="p">,</span> va <span class="o">=</span> <span class="s">&#39;bottom&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>plt.grid<span class="p">()</span>
</span><span class='line'>plt.legend<span class="p">(</span>loc <span class="o">=</span> <span class="s">&quot;lower left&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/example1preProc.png" width="616" height="462" title="'pre Procrustes 1'" >
<img class="center" src="http://paulidealiste.github.io/images/example2preProc.png" width="616" height="457" title="'pre Procrustes 2'" ></p>

<p>Procrustes superimposition revolves around three features of shape extraction, that is invariance of landmark configurations to position, scale and rotation. There are a number of excelent textbooks about the mathematics and logic, as well as procedures for Procrustes superimposition (Bookstein, 1991<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, Dryden and Mardia, 1998<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, Zelditch et al., 2012<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>), but for this post direct inspiration was <em>Morphometrics in R</em> (Claude, 2008), especially with the basic procedure presented in the following function definition.</p>

<figure class='code'><figcaption><span>Partial Procrustes superimposition of two configurations</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>def pProc<span class="p">(</span>mat1<span class="p">,</span> mat2<span class="p">)</span><span class="o">:</span>
</span><span class='line'>  k <span class="o">=</span> mat1.shape<span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="m">-1</span>
</span><span class='line'>  m <span class="o">=</span> mat1.shape<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>  sscaledMat1 <span class="o">=</span> mat1 <span class="o">/</span> centsize<span class="p">(</span>mat1<span class="p">)</span> <span class="c1">#scaling and centering</span>
</span><span class='line'>  sscaledMat2 <span class="o">=</span> mat2 <span class="o">/</span> centsize<span class="p">(</span>mat2<span class="p">)</span>
</span><span class='line'>  z1 <span class="o">=</span> sscaledMat1 <span class="o">-</span> <span class="p">[</span>sscaledMat1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>.mean<span class="p">(),</span> sscaledMat1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>.mean<span class="p">()]</span>
</span><span class='line'>  z2 <span class="o">=</span> sscaledMat2 <span class="o">-</span> <span class="p">[</span>sscaledMat2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">]</span>.mean<span class="p">(),</span> sscaledMat2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>.mean<span class="p">()]</span>
</span><span class='line'>  tempSv <span class="o">=</span> np.dot<span class="p">(</span>np.transpose<span class="p">(</span>z2<span class="p">),</span> z1<span class="p">)</span> <span class="c1">#rotation</span>
</span><span class='line'>  svdMat <span class="o">=</span> np.linalg.svd<span class="p">(</span>tempSv<span class="p">)</span>
</span><span class='line'>  U <span class="o">=</span> svdMat<span class="p">[</span><span class="m">0</span><span class="p">]</span>
</span><span class='line'>  V <span class="o">=</span> svdMat<span class="p">[</span><span class="m">2</span><span class="p">]</span>
</span><span class='line'>  Ds <span class="o">=</span> svdMat<span class="p">[</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>  tempSig <span class="o">=</span> np.linalg.det<span class="p">(</span>np.dot<span class="p">(</span>np.transpose<span class="p">(</span>z1<span class="p">),</span> z2<span class="p">))</span>
</span><span class='line'>  sig <span class="o">=</span> np.sign<span class="p">(</span>tempSig<span class="p">)</span>
</span><span class='line'>  Ds<span class="p">[</span>k<span class="p">]</span> <span class="o">=</span> sig <span class="o">*</span> np.absolute<span class="p">(</span>Ds<span class="p">[</span>k<span class="p">])</span>
</span><span class='line'>  U<span class="p">[</span><span class="o">:</span><span class="p">,</span>k<span class="p">]</span> <span class="o">=</span> sig <span class="o">*</span> U<span class="p">[</span><span class="o">:</span><span class="p">,</span>k<span class="p">]</span>
</span><span class='line'>  Gam <span class="o">=</span> np.dot<span class="p">(</span>V<span class="p">,</span> np.transpose<span class="p">(</span>U<span class="p">))</span>
</span><span class='line'>  beta <span class="o">=</span> np.sum<span class="p">(</span>Ds<span class="p">)</span>
</span><span class='line'>  pmat1 <span class="o">=</span> np.dot<span class="p">(</span>z1<span class="p">,</span> Gam<span class="p">)</span>
</span><span class='line'>  pmat2 <span class="o">=</span> z2
</span><span class='line'>  tempRot <span class="o">=</span> vstack<span class="p">((</span>pmat1<span class="p">,</span> pmat2<span class="p">))</span>
</span><span class='line'>  rotatedMat <span class="o">=</span> pd.DataFrame<span class="p">(</span>tempRot<span class="p">,</span> columns <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'>  <span class="kr">return</span> rotatedMat
</span></code></pre></td></tr></table></div></figure>


<p>Plot of the superimposed configurations reveals that the Procrustes python was really able to force monsters` shape be more similar, removing the effects of orientation, size and rotation.</p>

<figure class='code'><figcaption><span>Plot of the superimposed configurations</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>rotatedMon <span class="o">=</span> pProc<span class="p">(</span>monster1<span class="p">,</span> monster2<span class="p">)</span>
</span><span class='line'>rotatedMon1 <span class="o">=</span> np.array<span class="p">(</span>rotatedMon<span class="p">[</span><span class="o">:</span><span class="m">10</span><span class="p">])</span>
</span><span class='line'>rotatedMon2 <span class="o">=</span> np.array<span class="p">(</span>rotatedMon<span class="p">[</span><span class="m">10</span><span class="o">:</span><span class="m">20</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>plt.scatter<span class="p">(</span>rotatedMon1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> rotatedMon1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">80</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#FFD200&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> label <span class="o">=</span> <span class="s">&quot;super monster1&quot;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>rotatedMon1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> rotatedMon1<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;--&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#FFD200&quot;</span><span class="p">)</span>
</span><span class='line'>plt.scatter<span class="p">(</span>rotatedMon2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> rotatedMon2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">80</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#47BFDD&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> label <span class="o">=</span> <span class="s">&quot;super monster2&quot;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>rotatedMon2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> rotatedMon2<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;--&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#47BFDD&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>meanRotMon <span class="o">=</span> <span class="p">(</span>rotatedMon1 <span class="o">+</span> rotatedMon2<span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
</span><span class='line'>plt.scatter<span class="p">(</span>meanRotMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> meanRotMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> s <span class="o">=</span> <span class="m">90</span><span class="p">,</span> c <span class="o">=</span> <span class="s">&quot;#6a12c4&quot;</span><span class="p">,</span> edgecolors <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> label <span class="o">=</span> <span class="s">&quot;super mean monster&quot;</span><span class="p">)</span>
</span><span class='line'>plt.plot<span class="p">(</span>meanRotMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> meanRotMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">],</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;#6a12c4&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>labelsRot <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Landmark {0}&#39;</span>.format<span class="p">(</span>i<span class="p">)</span> <span class="kr">for</span> i <span class="kr">in</span> range<span class="p">(</span><span class="m">10</span><span class="p">)]</span>
</span><span class='line'><span class="kr">for</span> label<span class="p">,</span> x<span class="p">,</span> y <span class="kr">in</span> zip<span class="p">(</span>labelsRot<span class="p">,</span> meanRotMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">0</span><span class="p">],</span> meanRotMon<span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="m">1</span><span class="p">])</span><span class="o">:</span> <span class="c1">#annotate mean landmarks by numbers</span>
</span><span class='line'>  plt.annotate<span class="p">(</span>label<span class="p">,</span> xy <span class="o">=</span> <span class="p">(</span>x<span class="p">,</span> y<span class="m">+0.01</span><span class="p">),</span> ha <span class="o">=</span> <span class="s">&#39;right&#39;</span><span class="p">,</span> va <span class="o">=</span> <span class="s">&#39;bottom&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>plt.grid<span class="p">()</span>
</span><span class='line'>plt.legend<span class="p">(</span>loc <span class="o">=</span> <span class="s">&quot;lower left&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/example1Proc.png" width="616" height="454" title="'Procrustes monster'" >
<img class="center" src="http://paulidealiste.github.io/images/example2Proc.png" width="616" height="452" title="'Procrustes monster 2'" ></p>

<p>Following posts should continue on this one and describe how the partial Procrustes superimposition for multilple configurations can be performed with fabulous sientific python.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Bookstein, F.L. 1991. Morphometric tools for landmark data: Geometry and Biology. Cambridge University press, Cambridge, UK.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Dryden, I.E. and K.V. Mardia. 1998. Statistical shape analysis. Wiley, Chichester, UK.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Zelditch, M.L., Swidersk, D.L. and H.D. Sheets. 2012. Geometric morphometrics for biologists: A primer. Second edition, Elsevier. <a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R Generator and a Colorful PCA]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/02/23/r-generator-and-a-colorful-pca/"/>
    <updated>2014-02-23T11:24:16+01:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/02/23/r-generator-and-a-colorful-pca</id>
    <content type="html"><![CDATA[<p>As simple as it may seem, sample data generation is not a trivial task, especially when random landmarks are to be generated. Usually, one would use multivariate normal distribution-based generator (like mvrnorm in R`s MASS package) in order to generate correlated data. The following function was used to generate data similar to the real world datased, unfortunately based directly on it, by using the coefficients from regressions between successive columns in a data matrix, which represent landmark coordinates in XY data matrix. The following function uses <a href="http://goo.gl/ijI1kn" target="_blank">this</a> data matrix (446 individuals and 28 landmarks), and performs regressions between X-Y pairs for all coordinates. Finally it uses intercepts and slopes to infer mean and SD for rnorm function, random number generator.</p>

<figure class='code'><figcaption><span>Resampler function for random resamples of a real data matrix</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>resampler <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>mat<span class="p">)</span> <span class="c1">#simulations based on rnorm random sampling</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  x <span class="o">&lt;-</span> dim<span class="p">(</span>mat<span class="p">)[</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>  y <span class="o">&lt;-</span> dim<span class="p">(</span>mat<span class="p">)[</span><span class="m">2</span><span class="p">]</span>
</span><span class='line'>  indexrow <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">2</span><span class="o">:</span>x<span class="p">)</span>
</span><span class='line'>  combinations <span class="o">&lt;-</span> matrix<span class="p">(</span>c<span class="p">(</span><span class="m">1</span><span class="o">:</span>y<span class="p">,</span><span class="m">2</span><span class="o">:</span>y<span class="p">),</span> ncol <span class="o">=</span> <span class="m">2</span><span class="p">)</span> <span class="c1">#ignore the warning message</span>
</span><span class='line'>  slope <span class="o">&lt;-</span> numeric<span class="p">(</span>y<span class="p">)</span>
</span><span class='line'>  intercept <span class="o">&lt;-</span> numeric<span class="p">(</span>y<span class="p">)</span>
</span><span class='line'>  sds <span class="o">&lt;-</span> numeric<span class="p">(</span>y<span class="p">)</span>
</span><span class='line'>  <span class="kr">for</span><span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>y<span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    veca <span class="o">&lt;-</span> mat<span class="p">[,</span>combinations<span class="p">[</span>i<span class="p">,]][,</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>    vecb <span class="o">&lt;-</span> mat<span class="p">[,</span>combinations<span class="p">[</span>i<span class="p">,]][,</span><span class="m">2</span><span class="p">]</span>
</span><span class='line'>    model <span class="o">&lt;-</span> lm<span class="p">(</span>veca<span class="o">~</span>vecb<span class="p">)</span>
</span><span class='line'>    slope<span class="p">[</span>i<span class="p">]</span> <span class="o">&lt;-</span> coef<span class="p">(</span>model<span class="p">)[</span><span class="m">2</span><span class="p">]</span>
</span><span class='line'>    intercept<span class="p">[</span>i<span class="p">]</span> <span class="o">&lt;-</span> coef<span class="p">(</span>model<span class="p">)[</span><span class="m">1</span><span class="p">]</span>
</span><span class='line'>    sds<span class="p">[</span>i<span class="p">]</span> <span class="o">&lt;-</span> sd<span class="p">(</span>mat<span class="p">[,</span>combinations<span class="p">[</span>i<span class="p">,]][,</span><span class="m">1</span><span class="p">])</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  coefs <span class="o">&lt;-</span> data.frame<span class="p">(</span>intercept<span class="p">,</span>slope<span class="p">,</span>sds<span class="p">)</span>
</span><span class='line'>  cexox <span class="o">&lt;-</span> data.frame<span class="p">(</span>c<span class="p">(</span><span class="m">1</span><span class="o">:</span>x<span class="p">))</span>
</span><span class='line'>  <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>y<span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    dataCol <span class="o">&lt;-</span> rnorm<span class="p">(</span>length<span class="p">(</span>mat<span class="p">[,</span>combinations<span class="p">[</span>i<span class="p">,]][,</span><span class="m">2</span><span class="p">]),</span>mean<span class="o">=</span>intercept<span class="p">[</span>i<span class="p">]</span><span class="o">+</span>slope<span class="p">[</span>i<span class="p">]</span><span class="o">*</span>mat<span class="p">[,</span>combinations<span class="p">[</span>i<span class="p">,]][,</span><span class="m">2</span><span class="p">],</span>sd<span class="o">=</span>sds<span class="p">)</span>
</span><span class='line'>    cexox <span class="o">&lt;-</span> cbind<span class="p">(</span>cexox<span class="p">,</span> dataCol<span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  sampleMatrix <span class="o">&lt;-</span> as.matrix<span class="p">(</span>cexox<span class="p">)</span>
</span><span class='line'>  sampleMatrix <span class="o">&lt;-</span> sampleMatrix<span class="p">[,</span><span class="m">-1</span><span class="p">]</span>
</span><span class='line'>  <span class="kr">return</span><span class="p">(</span>sampleMatrix<span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>resampledCap <span class="o">&lt;-</span> resampler<span class="p">(</span>capreolusMatrix<span class="p">)</span> <span class="c1">#resample the original matrix-generate random coordinates</span>
</span></code></pre></td></tr></table></div></figure>


<p>When the function finishes the output is also an XY matrix, which needs to be converted to an array in order to use it in gpagen function from the <em>geomorph</em> package. After that the procedure follows all the usual steps of the GM analysis, with the exception of factor levels generation in order to simulate grouping, and finally performing PCA on the Procrustes shape variables.</p>

<figure class='code'><figcaption><span>Basic GM procedures and factor level generation</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>library<span class="p">(</span>geomorph<span class="p">)</span>
</span><span class='line'>capreolusArray <span class="o">&lt;-</span> arrayspecs<span class="p">(</span>resampledCap<span class="p">,</span> <span class="m">28</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> byLand <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span><span class='line'>capreolusGPA <span class="o">&lt;-</span> gpagen<span class="p">(</span>capreolusArray<span class="p">,</span> ShowPlot <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span><span class='line'>pop <span class="o">&lt;-</span> sample<span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">446</span><span class="p">,</span> replace <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span> <span class="c1">#generate random 5 population partition</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">1</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop1&quot;</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">2</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop2&quot;</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">3</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop3&quot;</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">4</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop4&quot;</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">5</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop5&quot;</span>
</span><span class='line'>capreolusGPA2d <span class="o">&lt;-</span> two.d.array<span class="p">(</span>capreolusGPA<span class="o">$</span>coords<span class="p">)</span> <span class="c1">#get the data in XY format for PCA</span>
</span></code></pre></td></tr></table></div></figure>


<p>PCA is then done using the usual R`s prcomp function and <em>ggplot2</em> for plotting the data points using fantastic <a href="http://colorbrewer2.org/" target="_blank">ColorBrewer</a> color schemes (which are the names of types and palettes in <em>ggplot2</em> scale_color_brewer geom). In order to fine-tune the PCA figure, the ggplot2 can also use custom fonts for plot annotation. Prior to that, fonts must be imported and registered, which is greatly facilitated by using the <em>extrafont</em> library.</p>

<figure class='code'><figcaption><span>PCA and ggplot2 code for a PCA scatterplot</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>capPCAwhole <span class="o">&lt;-</span> prcomp<span class="p">(</span>capreolusGPA2d<span class="p">)</span>
</span><span class='line'>capPCA <span class="o">&lt;-</span> data.frame<span class="p">(</span>capPCAwhole<span class="o">$</span>x<span class="p">[,</span><span class="m">1</span><span class="p">],</span> capPCAwhole<span class="o">$</span>x<span class="p">[,</span><span class="m">2</span><span class="p">],</span> capPCAwhole<span class="o">$</span>x<span class="p">[,</span><span class="m">3</span><span class="p">],</span> capPCAwhole<span class="o">$</span>x<span class="p">[,</span><span class="m">4</span><span class="p">])</span>
</span><span class='line'>capPCA <span class="o">&lt;-</span> data.frame<span class="p">(</span>capPCA<span class="p">,</span> pop<span class="p">)</span>
</span><span class='line'>names<span class="p">(</span>capPCA<span class="p">)</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;PC1&quot;</span><span class="p">,</span><span class="s">&quot;PC2&quot;</span><span class="p">,</span><span class="s">&quot;PC3&quot;</span><span class="p">,</span><span class="s">&quot;PC4&quot;</span><span class="p">,</span><span class="s">&quot;pop&quot;</span><span class="p">)</span> <span class="c1">#prepare a data.frame for ggplot2</span>
</span><span class='line'>meanPCA1 <span class="o">&lt;-</span> aggregate<span class="p">(</span>capPCA<span class="p">[,</span><span class="m">1</span><span class="p">],</span> mean<span class="p">,</span> by <span class="o">=</span> list<span class="p">(</span>capPCA<span class="p">[,</span><span class="m">5</span><span class="p">]))</span> <span class="c1">#calculate average PC score per group for plotting</span>
</span><span class='line'>meanPCA2 <span class="o">&lt;-</span> aggregate<span class="p">(</span>capPCA<span class="p">[,</span><span class="m">2</span><span class="p">],</span> mean<span class="p">,</span> by <span class="o">=</span> list<span class="p">(</span>capPCA<span class="p">[,</span><span class="m">5</span><span class="p">]))</span>
</span><span class='line'>meanPCA <span class="o">&lt;-</span> data.frame<span class="p">(</span>meanPCA1<span class="p">,</span> meanPCA2<span class="p">[,</span><span class="m">2</span><span class="p">])</span>
</span><span class='line'>names<span class="p">(</span>meanPCA<span class="p">)</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;pop&quot;</span><span class="p">,</span><span class="s">&quot;PC1&quot;</span><span class="p">,</span><span class="s">&quot;PC2&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>library<span class="p">(</span>extrafont<span class="p">)</span> <span class="c1">#for using i.e. Times New Roman Fonts in ggplots</span>
</span><span class='line'>font_import<span class="p">(</span>pattern<span class="o">=</span><span class="s">&quot;[T/t]imes&quot;</span><span class="p">)</span> <span class="c1">#this imports Times font family</span>
</span><span class='line'>loadfonts<span class="p">(</span>device<span class="o">=</span><span class="s">&quot;pdf&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>library <span class="p">(</span>ggplot2<span class="p">)</span>
</span><span class='line'>theme_set<span class="p">(</span>theme_bw<span class="p">())</span>
</span><span class='line'>pcaplot <span class="o">&lt;-</span> ggplot<span class="p">(</span>capPCA<span class="p">,</span> aes<span class="p">(</span>x<span class="o">=</span>PC1<span class="p">,</span> y<span class="o">=</span>PC2<span class="p">,</span> group <span class="o">=</span> pop<span class="p">))</span> <span class="o">+</span> geom_point<span class="p">(</span>size <span class="o">=</span> <span class="m">7</span><span class="p">,</span> shape <span class="o">=</span> <span class="m">19</span><span class="p">,</span> aes<span class="p">(</span>color<span class="o">=</span>pop<span class="p">))</span> <span class="o">+</span> scale_color_brewer<span class="p">(</span>palette<span class="o">=</span><span class="s">&quot;Set1&quot;</span><span class="p">)</span>
</span><span class='line'>pcaplot <span class="o">&lt;-</span> pcaplot <span class="o">+</span> theme<span class="p">(</span>panel.grid.major <span class="o">=</span> element_line<span class="p">(</span>size <span class="o">=</span> <span class="m">0.8</span><span class="p">,</span> linetype <span class="o">=</span> <span class="m">2</span><span class="p">))</span> <span class="o">+</span> theme<span class="p">(</span>panel.grid.minor <span class="o">=</span> element_line<span class="p">(</span>size <span class="o">=</span> <span class="m">1</span><span class="p">,</span> linetype <span class="o">=</span> <span class="m">2</span><span class="p">))</span>
</span><span class='line'>pcaplot <span class="o">&lt;-</span> pcaplot <span class="o">+</span> theme<span class="p">(</span>text<span class="o">=</span>element_text<span class="p">(</span>size<span class="o">=</span><span class="m">20</span><span class="p">,</span> family<span class="o">=</span><span class="s">&quot;Times New Roman&quot;</span><span class="p">),</span> legend.text<span class="o">=</span>element_text<span class="p">(</span>size <span class="o">=</span> <span class="m">22</span><span class="p">,</span> family <span class="o">=</span> <span class="s">&quot;Times New Roman&quot;</span><span class="p">),</span> legend.title <span class="o">=</span> element_text<span class="p">(</span>family <span class="o">=</span><span class="s">&quot;Times New Roman&quot;</span><span class="p">))</span> <span class="o">+</span> xlab<span class="p">(</span><span class="s">&quot;PC1&quot;</span><span class="p">)</span> <span class="o">+</span> ylab<span class="p">(</span><span class="s">&quot;PC2&quot;</span><span class="p">)</span>
</span><span class='line'>pcaplot <span class="o">&lt;-</span> pcaplot <span class="o">+</span> geom_point<span class="p">(</span>data <span class="o">=</span> meanPCA<span class="p">,</span> size <span class="o">=</span> <span class="m">14</span><span class="p">,</span> shape <span class="o">=</span> <span class="m">19</span><span class="p">)</span> <span class="o">+</span> geom_text<span class="p">(</span>data <span class="o">=</span> meanPCA<span class="p">,</span> size <span class="o">=</span> <span class="m">10</span><span class="p">,</span> label <span class="o">=</span> meanPCA<span class="o">$</span>pop<span class="p">,</span> family <span class="o">=</span> <span class="s">&quot;Times New Roman&quot;</span><span class="p">,</span> vjust <span class="o">=</span> <span class="m">-0.9</span><span class="p">)</span>
</span><span class='line'>pcaplot
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/pcaplot.png" width="616" height="466" title="'PCA'" ></p>

<p>The plot indicates very little differentiation between the populations, but I guess that`s well expected since so much randomness is at hand.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XY Outlines in GIMP and imageJ]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/02/01/xy-outlines-in-gimp-and-imagej/"/>
    <updated>2014-02-01T11:23:55+01:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/02/01/xy-outlines-in-gimp-and-imagej</id>
    <content type="html"><![CDATA[<p>This post continues on the first post about outline deformations and presents a simple way for generating outlines as XY data. XY format is very convenient for representing outline and line art in R or python. This type of visualization can be produced using <a href="http://www.gimp.org" target="_blank">GIMP</a> and <a href="http://rsbweb.nih.gov/ij" target="_blank">imageJ</a> through a sequence of easy steps. GIMP enables easy extraction of the central object from the image background. First step in outline extraction should be the precise definition of the object boundaries, such that the contrast between the object and the background is maximal. Example picture for this post is available <a href="http://goo.gl/bkirX7" target="_blank">here</a>. After opening the picture in GIMP workspace it looks like in Figure 1.</p>

<p><img src="http://paulidealiste.github.io/images/Gimp1.png" width="375" height="289" title="'Gimp import'" > <img class="right" src="http://paulidealiste.github.io/images/Gimp2.png" width="375" height="290" title="'Gimp scissors'" ></p>

<p>The easiest way to separate this chamois cranium from its background is to use <code>Scissor Select Tool</code> from the GIMP toolbox. This tool can nicely track the path between sucessive control points that should be placed along the desired object (Figure 2). When control points are placed along the shape, selection can be completed by pressing enter, and the background can be deleted by inverting selection pressing <code>Ctrl+I</code>. and deleting it using the delete key (Figure 3). Selection should be inverted once more and converted to path; from the <code>Select</code> menu <code>To Path</code>. Finally, stroke path (Figure 4, path card and right click on selection, <code>Stroke path</code>) gives the desired outline that can be exported as .tiff for imageJ through <code>Export</code> in the <code>File</code> menu.</p>

<p><img src="http://paulidealiste.github.io/images/Gimp3.png" width="375" height="290" title="'Gimp no background'" > <img class="right" src="http://paulidealiste.github.io/images/Gimp4.png" width="375" height="289" title="'Gimp stroke path'" ></p>

<p>In imageJ, picture should be converted to binary in <code>Process</code> menu, by selecting <code>Binary</code> and <code>Make Binary</code>. Final step is saving the binary image selection as XY data. First the outline should be selected by the magic wand selection tool (Figure 5) and then the image should be saved in XY format, in <code>File</code> menu, <code>Save as</code> and select <code>XY coordinates</code>. The XY data is also available <a href="http://goo.gl/d44PxK" target="_blank">here</a>.</p>

<p><img src="http://paulidealiste.github.io/images/GimpNo.png" width="310" height="326" title="'imageJ'" ></p>

<p>Now the .txt file could be easily imported into R and python.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Random Landmark Monsters in Python]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/01/17/simple-random-landmarks-in-python/"/>
    <updated>2014-01-17T11:36:06+01:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/01/17/simple-random-landmarks-in-python</id>
    <content type="html"><![CDATA[<p>Generating random datasets is facilitated by powerful algorithms in both R and python that are capable of drawing random numbers from predefined distributions. For simulating geometric morphometric data the only important constraint is correlation between x and y coordinates of landmarks. Spacing of landmarks in also important, especially if the aim is to generte life-like data set, but it is not essential (hopefully) for morphometric analyses to work. Python scipy stack (<em>numpy</em>, <em>scipy</em>, <em>pandas</em> and <em>matplotlib</em> + Ipython console) is a great budnle which enables both random number generators and great visualizations. The code presented in this post uses all of these libraries, especially <em>pandas</em>, which offer the basic data structure used for storing landmark data, DataFrame. Also, it can just be pasted into Ipython console window (afer installing any of the scipy stack python distributions). The basic idea is to use uniform distribution random number generator (line 7) in order to generate ranges for the spacing of landmark groups, and then multivariate normal random distribution for creating the two-column correlated data (x, y coordinates, line 8). This code will simulate the situation with 10 landmarks recorded on 200 individuals. Spacing of landmarks can be controlled by the ranges of uniform generators (175-220 in code), and the spread of landmarks is contolled by input covariance matrix for multivariate normal generators ([[3,0],[0,3]] in code).</p>

<figure class='code'><figcaption><span>Importing libraries and generating random landmarks</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">brewer2mpl</span> <span class="kn">as</span> <span class="nn">bmpl</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">scipy.interpolate</span>
</span><span class='line'>
</span><span class='line'><span class="n">coordstest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">175</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">175</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span> <span class="c">#genereta coordinate ranges - spacing of landmarks</span>
</span><span class='line'><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">coordstest</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="mi">200</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span> <span class="c">#correlated x and y from multivariate normal</span>
</span><span class='line'><span class="n">coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c">#generate factor coodinates each landmark has 200 recorded points</span>
</span><span class='line'><span class="n">coordinates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
</span><span class='line'><span class="n">allCoords</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span> <span class="c">#coordinates DataFrame</span>
</span><span class='line'><span class="n">allCoords</span><span class="p">[</span><span class="s">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coordinates</span>
</span><span class='line'><span class="n">meanCoords</span> <span class="o">=</span> <span class="n">allCoords</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;coordinates&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="c">#mean landmark coordiantes</span>
</span><span class='line'><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">ind</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
</span><span class='line'><span class="n">meanCoords</span><span class="p">[</span><span class="s">&#39;ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
</span></code></pre></td></tr></table></div></figure>


<p>allCoords contain all generated landmarks, while meanCoords is the collection of mean coordinates for each landmark. In order to visualize the generated data, a convenient &ldquo;outline&rdquo; can be drawn, connecting all landmarks smoothly. Since generated landmarks are not ordered in a way that permits simple connect-the-dots line between them, they should be rotated, and ordered differently. This can be done by using the centroid coordinates (from all landmarks) and the polar angle between the lines connecting centroid and each landmark. If polar angle is used, then landmarks (from meanCoords) can be ordered according to its value, clockwise. Polar angle can be calculated as the arctan between x and y coordinates of mean landmarks and the centroid.</p>

<figure class='code'><figcaption><span>Calculating polar angle and re-ordering of the meanCoords</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">meanCoords</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">])</span> <span class="c">#convenience function</span>
</span><span class='line'><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">meanCoords</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
</span><span class='line'><span class="n">cent</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">meanCoords</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">meanCoords</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">meanCoords</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">meanCoords</span><span class="p">))</span> <span class="c">#the overall centroid</span>
</span><span class='line'><span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c">#summary polar angle of all points</span>
</span><span class='line'><span class="n">points</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'><span class="n">angle</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
</span><span class='line'><span class="n">points</span><span class="p">[</span><span class="s">&#39;angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>
</span><span class='line'><span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;angle&#39;</span><span class="p">)</span> <span class="c">#sort by polar angle from the centroid</span>
</span></code></pre></td></tr></table></div></figure>


<p>If a path would be drawn between the mean landmarks now, it would be irregular, and not too informative. One way of constructing the smooth connection between landmarks is to use interpolation algorithms that are part of <em>scipy.interpolate</em>. One issue with this approach is the connection between the first and the last landmark, since it must be added to points DataFrame as eleventh landmark, with x,y coords the same as for the first one, in order to complete the path. This added segment behaves erratically during interpolation so the generated figures might be distorted. But this will not happen always and all program routines could be re-run as long as the desired, nice, result emerges.</p>

<figure class='code'><figcaption><span>Interpolation of the outline data</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">x_hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">])</span>
</span><span class='line'><span class="n">x_hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_hull</span><span class="p">,</span> <span class="n">x_hull</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c">#add first landmark as the last one (x)</span>
</span><span class='line'><span class="n">y_hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
</span><span class='line'><span class="n">y_hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_hull</span><span class="p">,</span> <span class="n">y_hull</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c">#add first landmark as the last one (y)</span>
</span><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x_hull</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span><span class='line'><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x_hull</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x_hull</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_hull</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">y_hull</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span><span class='line'><span class="n">t</span> <span class="o">/=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span><span class='line'><span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="n">x1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">spline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_hull</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span> <span class="c">#interpolated coordines for smooth lines</span>
</span><span class='line'><span class="n">y1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">spline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y_hull</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally, plots are produced sequentially, first all landmarks, then mean landmarks, and finally the outline.</p>

<figure class='code'><figcaption><span>Plotting</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">allCoords</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">],</span> <span class="n">allCoords</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">],</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&quot;#FFD699&quot;</span><span class="p">,</span> <span class="n">edgecolors</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span><span class="p">)</span> <span class="c">#plot all sampled points</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ind</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">bmpl</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="s">&#39;Set3&#39;</span><span class="p">,</span> <span class="s">&#39;qualitative&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">mpl_colormap</span><span class="p">)</span> <span class="c">#plot means with color brewer palette</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&quot;#97CAFF&quot;</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="c">#plot outlines</span>
</span><span class='line'><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Landmark {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</span><span class='line'><span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]):</span> <span class="c">#annotate mean landmarks by numbers</span>
</span><span class='line'> <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mf">0.3</span><span class="p">),</span><span class="n">ha</span> <span class="o">=</span> <span class="s">&#39;right&#39;</span><span class="p">,</span> <span class="n">va</span> <span class="o">=</span> <span class="s">&#39;bottom&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/FigMonster1.png" width="600" height="466" title="'First monster'" >
<img class="center" src="http://paulidealiste.github.io/images/FigMonster2.png" width="600" height="445" title="'Second monster'" ></p>

<p>Generated &ldquo;monsters&rdquo; are just there to get the idea of a possible shape, although the create the impression of the &ldquo;outline&rdquo;, such that all landmarks are sampled from the outer perimeter of the object. The code presented would not be complete if it wasn`t for the help from people from stackoverflow (<a href="http://goo.gl/DWOCLJ">here</a>, <a href="http://goo.gl/y9Kpv3">here</a> and <a href="http://goo.gl/xwL4Dz">here</a>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Colorful Outlines for Shape Comparison]]></title>
    <link href="http://paulidealiste.github.io/blog/2014/01/09/colorful-outlines-for-shape-comparison/"/>
    <updated>2014-01-09T19:55:01+01:00</updated>
    <id>http://paulidealiste.github.io/blog/2014/01/09/colorful-outlines-for-shape-comparison</id>
    <content type="html"><![CDATA[<p>This procedure is based on the outlines generated from the digital photos using imageJ and converting imageJ images to x-y continuous outline data available from <a href="http://goo.gl/TYSzf0" target="_blank">here</a>. Its goal is to present a visual overview of global shape differences between individuals from natural populations, using landmark data from ventral projection of their crania. All outlines are based on deformation via Thin Plate Splines, using mean shapes for populations as deformation targets and references. Superimposition methods as well as preliminary GM analyses were done in R and marvelous <em>geomorph</em> package by Dean Adams and Erik Otarola-Castillo. Additionally, since one of the common points of contemporary scientific research is the reproducibility of solutions offered all posts will also contain randomly generated sample data that could be used similarly to real-world datasets. Sample generation can be very useful, especially in teaching, so I intend to focus on it in future posts.</p>

<figure class='code'><figcaption><span>Importing libraries and generating the basic dataset (files should be placed in your working directory)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>library<span class="p">(</span>geomorph<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>ggplot2<span class="p">)</span>
</span><span class='line'>library<span class="p">(</span>Morpho<span class="p">)</span>
</span><span class='line'>d <span class="o">&lt;-</span> read.table<span class="p">(</span><span class="s">&quot;ventralnoOutlineCap.txt&quot;</span><span class="p">)</span> <span class="c1">#outline data</span>
</span><span class='line'>load<span class="p">(</span><span class="s">&quot;capreolusRgen.RData&quot;</span><span class="p">)</span>
</span><span class='line'>capreolusArray <span class="o">&lt;-</span> capreolusSample1 <span class="c1">#or capreolusSample2-5</span>
</span></code></pre></td></tr></table></div></figure>


<p>The workspace &ldquo;capreolusRgen.RData&rdquo; (which can be downloaded from <a href="http://goo.gl/4uKerX" target="_blank">here</a>) contains several randomly generated datasetes of 657 individuals and 28 landmarks, named &ldquo;capreolusSample#&rdquo;. These data was generated on the basis of real-world values, using the linear regression model to control random number generators. The code that was used probably does not repoduce the sampling of landmarks well, especially regarding correlations between pairs of landmark coordinates or the landmarks that conform to the object symmetry, but for the purpose of illustration in this post, I hope they should be fine.</p>

<figure class='code'><figcaption><span>Procrustes superimposition</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>capreolusGPA <span class="o">&lt;-</span> gpagen<span class="p">(</span>capreolusArray<span class="p">,</span> ShowPlot <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span><span class='line'>pop <span class="o">&lt;-</span> sample<span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">657</span><span class="p">,</span> replace <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span> <span class="c1">#generate random 3 population partition</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">1</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop1&quot;</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">2</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop2&quot;</span>
</span><span class='line'>pop<span class="p">[</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="m">3</span><span class="p">)]</span> <span class="o">&lt;-</span> <span class="s">&quot;pop3&quot;</span>
</span><span class='line'>capreolus <span class="o">&lt;-</span> capreolusGPA<span class="o">$</span>coords <span class="c1">#extract landmark coordinates</span>
</span></code></pre></td></tr></table></div></figure>


<p>Following the Procrustes superimposition is the calculation of mean shapes, both for all males and for separate populations. After mean shapes are calculated the only thing left is to use TPS in order to deform outlines (variable d), using mean shape of all males as a reference and mean shape of populations as target. This can all be done using <em>Morpho</em> R-package from Stefan Schlager.</p>

<figure class='code'><figcaption><span>Mean shapes and TPS deformations</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>meanCap <span class="o">&lt;-</span> mshape<span class="p">(</span>capreolus<span class="p">)</span>
</span><span class='line'>meanPop1 <span class="o">&lt;-</span> mshape<span class="p">(</span>capreolus<span class="p">[,,</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="s">&quot;pop1&quot;</span><span class="p">)])</span> <span class="c1">#by population</span>
</span><span class='line'>meanPop2 <span class="o">&lt;-</span> mshape<span class="p">(</span>capreolus<span class="p">[,,</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="s">&quot;pop2&quot;</span><span class="p">)])</span>
</span><span class='line'>meanPop3 <span class="o">&lt;-</span> mshape<span class="p">(</span>capreolus<span class="p">[,,</span>which<span class="p">(</span>pop <span class="o">==</span> <span class="s">&quot;pop3&quot;</span><span class="p">)])</span>
</span><span class='line'>pop1 <span class="o">&lt;-</span> data.frame<span class="p">(</span>tps3d<span class="p">(</span>as.matrix<span class="p">(</span>d<span class="p">),</span> meanCap<span class="p">,</span> meanPop1<span class="p">))</span> <span class="c1">#for each population</span>
</span><span class='line'>pop2 <span class="o">&lt;-</span> data.frame<span class="p">(</span>tps3d<span class="p">(</span>as.matrix<span class="p">(</span>d<span class="p">),</span> meanCap<span class="p">,</span> meanPop2<span class="p">))</span>
</span><span class='line'>pop3 <span class="o">&lt;-</span> data.frame<span class="p">(</span>tps3d<span class="p">(</span>as.matrix<span class="p">(</span>d<span class="p">),</span> meanCap<span class="p">,</span> meanPop3<span class="p">))</span>
</span><span class='line'>capWhole <span class="o">&lt;-</span> rbind<span class="p">(</span>pop1<span class="p">,</span> pop2<span class="p">,</span> pop3<span class="p">)</span> <span class="c1">#combine data</span>
</span><span class='line'>pops <span class="o">&lt;-</span> c<span class="p">(</span>rep<span class="p">(</span><span class="s">&quot;pop1&quot;</span><span class="p">,</span> <span class="m">2836</span><span class="p">),</span> rep<span class="p">(</span><span class="s">&quot;pop2&quot;</span><span class="p">,</span> <span class="m">2836</span><span class="p">),</span> rep<span class="p">(</span><span class="s">&quot;pop3&quot;</span><span class="p">,</span> <span class="m">2836</span><span class="p">))</span> <span class="c1">#outline has 2836 points</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally, depicting shape changes can be achieved by wonderful Hadley Wickham`s <em>ggplot2</em> R-package. This package has a neat way of &ldquo;forcing&rdquo; you to keep your data organized, so all variables are inside one data frame, both quantitative and qualitative.</p>

<figure class='code'><figcaption><span>ggplot2 plotting of shape outline deformations</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='r'><span class='line'>wholeCap <span class="o">&lt;-</span> data.frame<span class="p">(</span>capWhole<span class="p">,</span> pops<span class="p">)</span> <span class="c1">#deformed outlines and population membership</span>
</span><span class='line'>theme_set<span class="p">(</span>theme_bw<span class="p">())</span> <span class="c1">#change default ggplot theme to b&amp;w</span>
</span><span class='line'>dplot <span class="o">&lt;-</span> ggplot<span class="p">(</span>wholeCap<span class="p">,</span> aes<span class="p">(</span>wholeCap<span class="p">[,</span><span class="m">1</span><span class="p">],</span>wholeCap<span class="p">[,</span><span class="m">2</span><span class="p">],</span> group <span class="o">=</span> pops<span class="p">))</span> <span class="c1">#initialize ggplot object</span>
</span><span class='line'>dplot <span class="o">&lt;-</span> dplot <span class="o">+</span> geom_path<span class="p">(</span>size <span class="o">=</span> <span class="m">1</span><span class="p">,</span> aes<span class="p">(</span>color <span class="o">=</span> pops<span class="p">))</span> <span class="o">+</span> facet_grid<span class="p">(</span>.<span class="o">~</span>pops<span class="p">)</span> <span class="c1">#add layers</span>
</span><span class='line'>dplot <span class="o">+</span> theme<span class="p">(</span>axis.title <span class="o">=</span> element_blank<span class="p">(),</span> axis.text <span class="o">=</span> element_blank<span class="p">(),</span> axis.ticks <span class="o">=</span> element_blank<span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://paulidealiste.github.io/images/post1outline.png" width="616" height="546" title="'Outlines'" ></p>

<p>By inspecting outlines it can be seen that the individuals from pop1 are the smallest while the ones from pop2 are the largest. Shape differences are also determined by the relationship of length to width, so that individuals from pop2 have the widest crania, while the ones from pop1 have the narrowest. Also, it can be seen that in the individuals with the largest crania, size differences are detemined mostly by dimensions of the anterior part, maxillary and rostral regions, that are both wider and longer with respect to individuals with smaller crania. Posterior part of the cranium is more similar between individuals from different populations, and it may be more stable.</p>
]]></content>
  </entry>
  
</feed>
